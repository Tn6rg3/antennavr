<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Ham Radio - Plane Intersection</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; touch-action: none; color: white;}
        
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; z-index: 100; pointer-events: none; padding: 5px; box-sizing: border-box; }
        #top-bar { display: flex; justify-content: space-between; width: 100%; }

        #dataPanel { background: rgba(0, 0, 0, 0.85); padding: 10px; border-radius: 8px; font-size: 13px; width: fit-content; max-width: 45%; pointer-events: auto; border-left: 3px solid #ffdd59; }
        .data-value { font-weight: bold; color: #ffdd59; font-size: 15px; }

        #antennaPanel { background: rgba(20, 40, 60, 0.95); padding: 10px; border-radius: 8px; font-size: 14px; width: 48%; pointer-events: auto; border: 2px solid #1e90ff; display: none; }
        #antennaPanel select, #antennaPanel input { width: 100%; margin-top: 5px; margin-bottom: 10px; padding: 8px; background: #222; color: white; border: 1px solid #777; border-radius: 5px; font-size: 14px; box-sizing: border-box;}
        .ant-settings { display: none; }
        #warning { color: #ff4757; font-weight: bold; font-size: 12px; display: none; margin-top: 5px;}

        .bottom-controls { display: flex; flex-direction: column; align-items: center; gap: 5px; width: 100%; }
        .btn-row { display: flex; gap: 5px; pointer-events: auto; width: 100%; justify-content: center; }
        .main-btn { padding: 10px 5px; font-size: 13px; font-weight: bold; flex: 1; border-radius: 8px; border: 2px solid transparent; cursor: pointer; color: white; opacity: 0.7; transition: 0.2s; }
        .main-btn.active { opacity: 1; border-color: white; transform: scale(1.02); }
        
        #btnGround { background: #2ed573; color: black; }
        #btnA { background: #ff4757; }
        #btnB { background: #1e90ff; }
        #btnPhoto { background: #ffffff; color: black; font-size: 14px; }
        #btnReset { background: #ff9f43; color: black; font-size: 14px; }
        
        #instruction { text-align: center; color: #fff; font-weight: bold; background: #e1b12c; padding: 6px; border-radius: 5px; width: 100%; box-sizing: border-box; font-size: 13px;}
        
        .edit-panel { background: rgba(30,30,30,0.95); padding: 8px; border-radius: 8px; width: 100%; pointer-events: auto; box-sizing: border-box; text-align: center;}
        .edit-row { display: flex; justify-content: center; gap: 10px; margin-top: 5px; width: 100%;}
        .edit-btn { padding: 10px 15px; font-size: 14px; background: #444; color: white; border: 1px solid #777; border-radius: 5px; font-weight: bold; cursor: pointer; flex: 1;}
        .edit-btn:active { background: #888; }
        
        .height-input-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; }
        #phoneHeight { width: 60px; padding: 5px; font-size: 16px; text-align: center; font-weight: bold; border-radius: 4px; border: none;}
        
        #touchArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: -1; }
        #photoOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(46, 213, 115, 0.9); color: black; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; display: none; z-index: 200; box-shadow: 0 4px 6px rgba(0,0,0,0.5);}
    </style>
</head>
<body>

    <div id="ui-container" style="display: none;">
        <div id="touchArea"></div>
        <div id="top-bar">
            <div id="dataPanel">
                <strong>QUOTE (dal suolo):</strong><br>
                A: <span id="hA" class="data-value">--</span>m<br>
                B: <span id="hB" class="data-value">--</span>m<br>
                <hr style="border-color:#555; margin: 5px 0;">
                Distanza A-B:<br><span id="distAB" class="data-value" style="font-size: 18px;">--</span>m
            </div>

            <div id="antennaPanel">
                <strong>Configura Antenna</strong>
                <select id="antType">
                    <option value="dipole" selected>Dipolo</option>
                    <option value="endfed">End Fed</option>
                    <option value="longwire">Long Wire</option>
                    <option value="none">Solo Filo</option>
                </select>

                <div id="setDipole" class="ant-settings">
                    Banda:<br>
                    <select id="dipoleBand">
                        <option value="160">160m (~80m filo)</option>
                        <option value="80">80m (~40m filo)</option>
                        <option value="40">40m (~20m filo)</option>
                        <option value="20">20m (~10m filo)</option>
                        <option value="15">15m (~7m filo)</option>
                        <option value="10">10m (~5m filo)</option>
                        <option value="6">6m (~3m filo)</option>
                        <option value="4">4m (~2m filo)</option>
                        <option value="2">2m (~1m filo)</option>
                    </select>
                </div>
                <div id="setEndFed" class="ant-settings">
                    Start:<br><select id="efStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
                    Corda (m): <input type="number" id="efDist" value="1" step="0.5">
                    L1 (m): <input type="number" id="efL1" value="10" step="0.5">
                    L2 (m): <input type="number" id="efL2" value="2" step="0.5">
                </div>
                <div id="setLongWire" class="ant-settings">
                    Start:<br><select id="lwStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
                    Lunghezza (m): <input type="number" id="lwLen" value="20" step="1">
                </div>
                <div id="warning">‚ö†Ô∏è Antenna pi√π lunga dello spazio!</div>
            </div>
        </div>

        <div class="bottom-controls">
            
            <div id="panel-setup-ground" class="edit-panel" style="display: none;">
                <div style="font-size: 13px; margin-bottom: 8px; color: #2ed573;">CALIBRAZIONE MATEMATICA</div>
                <div class="height-input-container">
                    H Fotocamera: <input type="number" id="phoneHeight" value="1.40" step="0.05"> m
                </div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnSetByHeight" style="background:#2ed573; color:black;">Fissa Quota Zero</button>
                </div>
            </div>

            <div id="panel-edit-planes" class="edit-panel" style="display: none;">
                <div id="plane-instruction-text" style="font-size: 12px; margin-bottom: 5px; color: #aaa;">üëÜ Trascina il dito per allineare il quadrato.</div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnPFar">Allontana ‚ÜóÔ∏è</button>
                    <button class="edit-btn" id="btnPNear">Avvicina ‚ÜôÔ∏è</button>
                </div>
                
                <div class="edit-row" id="plane-actions-1" style="display:none;">
                    <button class="edit-btn" id="btnNextPlane" style="background:#1e90ff;">Vai al 2¬∞ Piano</button>
                </div>
                
                <div class="edit-row" id="plane-actions-2" style="display:none;">
                    <button class="edit-btn" id="btnSwitchPlane" style="background:#555;">Passa al Piano 1</button>
                    <button class="edit-btn" id="btnConfirmPoint" style="background:#2ed573; color:black;">Fissa Punto Finale</button>
                </div>
            </div>

            <div id="panel-edit-point" class="edit-panel" style="display: none;">
                <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">üëÜ TRASCINA per micro-correzioni finali.</div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnPFinalFar">Lontano ‚ÜóÔ∏è</button>
                    <button class="edit-btn" id="btnPFinalNear">Vicino ‚ÜôÔ∏è</button>
                </div>
            </div>

            <div id="instruction">Inizializzazione...</div>

            <div class="btn-row">
                <button id="btnGround" class="main-btn">1. Terreno</button>
                <button id="btnA" class="main-btn">2. Albero A</button>
                <button id="btnB" class="main-btn">3. Albero B</button>
            </div>
            <div class="btn-row">
                <button id="btnReset" class="main-btn">üîÑ Reset</button>
                <button id="btnPhoto" class="main-btn">üì∏ Foto</button>
            </div>
        </div>
    </div>
    
    <div id="photoOverlay">Usa i tasti screenshot! (Torno tra 5s)</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let container, camera, scene, renderer, controller, reticle;
        let hitTestSource = null, hitTestSourceRequested = false;

        let point1, point2, groundGrid, lineAB;
        let antennaMeshes = [], markerMeshes = [], textSprites = [];
        
        let groundLevel = 0, isGroundSet = false;
        let currentAction = 'NONE'; 

        // Nuovi Target (Quadrati Adattivi)
        let activePlane1, activePlane2;

        // Variabili Touch e Dragging
        let lastTouchX = 0, lastTouchY = 0, isDragging = false, hasDragged = false; 

        let targetReticlePosition = new THREE.Vector3();
        let targetReticleQuaternion = new THREE.Quaternion();

        init();
        animate();

        // Funzione per creare il quadrato di mira
        function createTargetPlane(colorHex) {
            const group = new THREE.Group();
            
            // Il piano semi trasparente
            const geo = new THREE.PlaneGeometry(1, 1);
            const mat = new THREE.MeshBasicMaterial({color: colorHex, transparent: true, opacity: 0.2, side: THREE.DoubleSide});
            const mesh = new THREE.Mesh(geo, mat);
            group.add(mesh);

            // I bordi e la croce
            const edgeGeo = new THREE.EdgesGeometry(geo);
            const lineMat = new THREE.LineBasicMaterial({color: colorHex, linewidth: 2});
            group.add(new THREE.LineSegments(edgeGeo, lineMat));

            const crossGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-0.5, 0, 0), new THREE.Vector3(0.5, 0, 0),
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.5, 0)
            ]);
            group.add(new THREE.LineSegments(crossGeo, lineMat));

            // Pallino centrale
            const dot = new THREE.Mesh(new THREE.SphereGeometry(0.03, 16, 16), new THREE.MeshBasicMaterial({color: 0xffffff}));
            group.add(dot);

            group.visible = false;
            scene.add(group);
            return group;
        }

        function init() {
            container = document.createElement( 'div' );
            document.body.appendChild( container );
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 200 );

            const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );
            light.position.set( 0.5, 1, 0.25 ); scene.add( light );

            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.xr.enabled = true;
            container.appendChild( renderer.domElement );

            document.body.appendChild( ARButton.createButton( renderer, { 
                requiredFeatures: [ 'hit-test', 'dom-overlay' ],
                domOverlay: { root: document.getElementById('ui-container') }
            } ) );

            groundGrid = new THREE.GridHelper( 3, 30, 0x2ed573, 0x2ed573 );
            groundGrid.material.opacity = 0.8; groundGrid.material.transparent = true; groundGrid.visible = false;
            scene.add( groundGrid );

            const pointGeo = new THREE.SphereGeometry( 0.05, 32, 32 );
            point1 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0xff4757 } ) ); point1.visible = false; scene.add( point1 );
            point2 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0x1e90ff } ) ); point2.visible = false; scene.add( point2 );

            lineAB = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: 0xffdd59, linewidth: 1 }));
            lineAB.visible = false; scene.add(lineAB);

            reticle = new THREE.Mesh( new THREE.RingGeometry( 0.02, 0.04, 32 ).rotateX( - Math.PI / 2 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
            reticle.matrixAutoUpdate = true; reticle.visible = false; scene.add( reticle );

            // Crea i due piani
            activePlane1 = createTargetPlane(0xff4757); // Rosso base
            activePlane2 = createTargetPlane(0xffdd59); // Giallo

            controller = renderer.xr.getController( 0 );
            controller.addEventListener( 'select', onSelect );
            scene.add( controller );

            window.addEventListener( 'resize', onWindowResize );

            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ui-container').style.display = 'flex';
                updateAntennaUI(); setAction('MENU_GROUND');
            });

            document.getElementById('ui-container').addEventListener('beforexrselect', (ev) => {
                if (ev.target.id !== 'touchArea') ev.preventDefault();
            });

            // MENU BOTTONI
            document.getElementById('btnGround').addEventListener('click', () => setAction('MENU_GROUND'));
            document.getElementById('btnSetByHeight').addEventListener('click', () => {
                const height = parseFloat(document.getElementById('phoneHeight').value);
                if(isNaN(height) || height <= 0) return;
                groundLevel = camera.position.y - height;
                groundGrid.position.set(camera.position.x, groundLevel, camera.position.z);
                groundGrid.visible = true; isGroundSet = true;
                setAction('NONE'); updateCalculations();
            });
            
            document.getElementById('btnA').addEventListener('click', () => setAction('PLACE_PLANE_A1'));
            document.getElementById('btnB').addEventListener('click', () => setAction('PLACE_PLANE_B1'));
            
            // Azioni dei piani
            document.getElementById('btnNextPlane').addEventListener('click', () => {
                if (currentAction === 'EDIT_PLANE_A1') setAction('PLACE_PLANE_A2');
                if (currentAction === 'EDIT_PLANE_B1') setAction('PLACE_PLANE_B2');
            });
            
            document.getElementById('btnSwitchPlane').addEventListener('click', () => {
                if (currentAction === 'EDIT_PLANE_A1') setAction('EDIT_PLANE_A2');
                else if (currentAction === 'EDIT_PLANE_A2') setAction('EDIT_PLANE_A1');
                else if (currentAction === 'EDIT_PLANE_B1') setAction('EDIT_PLANE_B2');
                else if (currentAction === 'EDIT_PLANE_B2') setAction('EDIT_PLANE_B1');
            });

            document.getElementById('btnConfirmPoint').addEventListener('click', () => {
                if(currentAction.includes('A')) {
                    point1.position.lerpVectors(activePlane1.position, activePlane2.position, 0.5);
                    point1.visible = true; activePlane1.visible = false; activePlane2.visible = false;
                    setAction('EDIT_A');
                } else {
                    point2.position.lerpVectors(activePlane1.position, activePlane2.position, 0.5);
                    point2.visible = true; activePlane1.visible = false; activePlane2.visible = false;
                    setAction('EDIT_B');
                }
                updateCalculations();
            });

            // Gestione profondit√† Piani
            document.getElementById('btnPFar').addEventListener('click', () => adjustDepth(0.5));
            document.getElementById('btnPNear').addEventListener('click', () => adjustDepth(-0.5));
            
            // Gestione profondit√† Pallino finale
            document.getElementById('btnPFinalFar').addEventListener('click', () => adjustDepth(0.5));
            document.getElementById('btnPFinalNear').addEventListener('click', () => adjustDepth(-0.5));

            document.getElementById('antType').addEventListener('change', updateAntennaUI);
            document.querySelectorAll('#antennaPanel select, #antennaPanel input').forEach(el => { el.addEventListener('change', drawAntenna); el.addEventListener('input', drawAntenna); });

            document.getElementById('btnPhoto').addEventListener('click', () => {
                document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'hidden');
                document.getElementById('antennaPanel').style.visibility = 'hidden';
                const toast = document.getElementById('photoOverlay');
                toast.style.display = 'block';
                setTimeout(() => {
                    toast.style.display = 'none';
                    document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'visible');
                    if (point1.visible && point2.visible) document.getElementById('antennaPanel').style.visibility = 'visible';
                }, 5000);
            });

            document.getElementById('btnReset').addEventListener('click', () => {
                point1.visible = false; point2.visible = false; groundGrid.visible = false; lineAB.visible = false;
                activePlane1.visible = false; activePlane2.visible = false;
                antennaMeshes.forEach(m => scene.remove(m)); antennaMeshes = [];
                markerMeshes.forEach(m => scene.remove(m)); markerMeshes = [];
                textSprites.forEach(m => scene.remove(m)); textSprites = [];
                isGroundSet = false; groundLevel = 0;
                document.getElementById('hA').innerText = '--'; document.getElementById('hB').innerText = '--'; document.getElementById('distAB').innerText = '--';
                document.getElementById('antType').value = 'dipole'; updateAntennaUI();
                document.getElementById('antennaPanel').style.display = 'none'; document.getElementById('warning').style.display = 'none';
                setAction('MENU_GROUND');
            });

            // DRAG TOUCH DINAMICO
            const touchArea = document.getElementById('touchArea');
            touchArea.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1 && currentAction.startsWith('EDIT_')) {
                    isDragging = true; hasDragged = false; lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
                }
            });
            touchArea.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                hasDragged = true; 
                if (e.touches.length === 1 && currentAction.startsWith('EDIT_')) {
                    
                    let pt;
                    if (currentAction === 'EDIT_A') pt = point1;
                    else if (currentAction === 'EDIT_B') pt = point2;
                    else if (currentAction.endsWith('1')) pt = activePlane1;
                    else if (currentAction.endsWith('2')) pt = activePlane2;
                    
                    if (!pt || !pt.visible) return;

                    let touchX = e.touches[0].clientX; let touchY = e.touches[0].clientY;
                    let deltaX = touchX - lastTouchX; let deltaY = touchY - lastTouchY;
                    let sensitivity = 0.001 * camera.position.distanceTo(pt.position); 
                    
                    let camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    let camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
                    pt.position.add(camRight.multiplyScalar(deltaX * sensitivity));
                    pt.position.add(camUp.multiplyScalar(-deltaY * sensitivity)); 
                    
                    lastTouchX = touchX; lastTouchY = touchY;
                    updateCalculations();
                }
            });
            touchArea.addEventListener('touchend', () => { isDragging = false; });
        }

        function setAction(action) {
            currentAction = action;
            document.getElementById('panel-setup-ground').style.display = 'none';
            document.getElementById('panel-edit-planes').style.display = 'none';
            document.getElementById('panel-edit-point').style.display = 'none';
            document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));

            let inst = document.getElementById('instruction');

            if (action === 'MENU_GROUND') {
                document.getElementById('btnGround').classList.add('active'); document.getElementById('panel-setup-ground').style.display = 'block';
                inst.innerText = "Scegli come impostare la quota zero del suolo."; inst.style.background = "#2ed573";
            } else if (action === 'PLACE_PLANE_A1' || action === 'PLACE_PLANE_B1') {
                const isA = action.includes('A');
                document.getElementById(isA ? 'btnA' : 'btnB').classList.add('active');
                activePlane1.visible = false; activePlane2.visible = false; // reset
                inst.innerText = "Punta il ramo e TOCCA per piazzare il 1¬∞ QUADRATO."; inst.style.background = isA ? "#ff4757" : "#1e90ff";
            } else if (action === 'PLACE_PLANE_A2' || action === 'PLACE_PLANE_B2') {
                const isA = action.includes('A');
                document.getElementById(isA ? 'btnA' : 'btnB').classList.add('active');
                inst.innerText = "Spostati, mira lo STESSO ramo e TOCCA per il 2¬∞ QUADRATO."; inst.style.background = isA ? "#ff4757" : "#1e90ff";
            } else if (action === 'EDIT_PLANE_A1' || action === 'EDIT_PLANE_B1' || action === 'EDIT_PLANE_A2' || action === 'EDIT_PLANE_B2') {
                const isA = action.includes('A');
                const isPlane1 = action.endsWith('1');
                document.getElementById(isA ? 'btnA' : 'btnB').classList.add('active');
                document.getElementById('panel-edit-planes').style.display = 'block';
                
                // Gestione dei bottoni UI in base allo stato
                if (!activePlane2.visible) {
                    document.getElementById('plane-actions-1').style.display = 'flex';
                    document.getElementById('plane-actions-2').style.display = 'none';
                    inst.innerText = "Centra il quadrato col dito, poi Vai al 2¬∞ Piano.";
                } else {
                    document.getElementById('plane-actions-1').style.display = 'none';
                    document.getElementById('plane-actions-2').style.display = 'flex';
                    document.getElementById('btnSwitchPlane').innerText = isPlane1 ? "Passa al Piano 2" : "Passa al Piano 1";
                    inst.innerText = `Muovi il PIANO ${isPlane1 ? '1' : '2'} per farli incrociare sul ramo!`;
                }
                inst.style.background = isA ? "#ff4757" : "#1e90ff";

            } else if (action === 'EDIT_A' || action === 'EDIT_B') {
                const btn = action === 'EDIT_A' ? 'btnA' : 'btnB';
                document.getElementById(btn).classList.add('active');
                document.getElementById('panel-edit-point').style.display = 'block';
                inst.innerText = "Punto fissato. Trascina se serve correggere."; inst.style.background = action === 'EDIT_A' ? "#ff4757" : "#1e90ff";
            } else {
                inst.innerText = "Antenna pronta. Usa il tasto Foto per salvare."; inst.style.background = "#555";
            }
        }

        function onSelect() {
            if (hasDragged) { hasDragged = false; return; }

            if (currentAction === 'PLACE_PLANE_A1' || currentAction === 'PLACE_PLANE_B1') {
                const distance = 10; // Distanza iniziale del piano
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                
                activePlane1.position.copy(camera.position).add(camDir.multiplyScalar(distance));
                activePlane1.quaternion.copy(camera.quaternion); // Fissa la rotazione frontale da QUESTA angolazione
                activePlane1.visible = true;
                
                setAction(currentAction === 'PLACE_PLANE_A1' ? 'EDIT_PLANE_A1' : 'EDIT_PLANE_B1');
            } 
            else if (currentAction === 'PLACE_PLANE_A2' || currentAction === 'PLACE_PLANE_B2') {
                const distance = 10;
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                
                activePlane2.position.copy(camera.position).add(camDir.multiplyScalar(distance));
                activePlane2.quaternion.copy(camera.quaternion); // Fissa la rotazione dalla NUOVA angolazione
                activePlane2.visible = true;
                
                setAction(currentAction === 'PLACE_PLANE_A2' ? 'EDIT_PLANE_A2' : 'EDIT_PLANE_B2');
            }
        }

        function adjustDepth(amount) {
            let pt;
            if (currentAction === 'EDIT_A') pt = point1;
            else if (currentAction === 'EDIT_B') pt = point2;
            else if (currentAction.endsWith('1')) pt = activePlane1;
            else if (currentAction.endsWith('2')) pt = activePlane2;

            if (!pt || !pt.visible) return;
            const toPoint = new THREE.Vector3().subVectors(pt.position, camera.position);
            toPoint.normalize(); // Muove lungo l'asse 3D esatto fotocamera-oggetto
            pt.position.add(toPoint.clone().multiplyScalar(amount));
            updateCalculations();
        }

        function updateCalculations() {
            if (isGroundSet && point1.visible) document.getElementById('hA').innerText = (point1.position.y - groundLevel).toFixed(1);
            if (isGroundSet && point2.visible) document.getElementById('hB').innerText = (point2.position.y - groundLevel).toFixed(1);
            if (point1.visible && point2.visible) {
                lineAB.geometry.setFromPoints([point1.position, point2.position]);
                lineAB.visible = true;
                document.getElementById('distAB').innerText = point1.position.distanceTo(point2.position).toFixed(1);
                document.getElementById('antennaPanel').style.display = 'block';
                drawAntenna();
            }
        }

        function updateAntennaUI() {
            const type = document.getElementById('antType').value;
            document.querySelectorAll('.ant-settings').forEach(el => el.style.display = 'none');
            if (type === 'dipole') document.getElementById('setDipole').style.display = 'block';
            if (type === 'endfed') document.getElementById('setEndFed').style.display = 'block';
            if (type === 'longwire') document.getElementById('setLongWire').style.display = 'block';
            drawAntenna();
        }

        function buildWire(pStart, pEnd, color, thickness=0.015) {
            const dist = pStart.distanceTo(pEnd);
            const cylinder = new THREE.Mesh( new THREE.CylinderGeometry(thickness, thickness, dist, 8), new THREE.MeshBasicMaterial({color: color}) );
            cylinder.position.copy(pStart).lerp(pEnd, 0.5);
            cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(pEnd, pStart).normalize());
            scene.add(cylinder); antennaMeshes.push(cylinder);
        }

        function makeTextSprite(message, textColor = '#ffffff', bgColor = 'rgba(0, 0, 0, 0.7)') {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 42px sans-serif'; ctx.fillStyle = textColor; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(message, 256, 64);
            const texture = new THREE.CanvasTexture(canvas); const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: false }); return new THREE.Sprite(spriteMat);
        }

        function drawDropLine(position, color, labelText) {
            if (!isGroundSet) return;
            const groundPos = new THREE.Vector3(position.x, groundLevel, position.z);
            const geo = new THREE.BufferGeometry().setFromPoints([position, groundPos]);
            const mat = new THREE.LineDashedMaterial({ color: color, dashSize: 0.2, gapSize: 0.2 });
            const line = new THREE.Line(geo, mat); line.computeLineDistances(); scene.add(line); antennaMeshes.push(line);
            const labelY = groundLevel + (position.y - groundLevel) * 0.3;
            const sprite = makeTextSprite(labelText, `#${color.toString(16).padStart(6, '0')}`); sprite.position.set(position.x, labelY, position.z); scene.add(sprite); textSprites.push(sprite);
        }

        function drawRopeLabel(pStart, pEnd) {
            const dist = pStart.distanceTo(pEnd); if (dist < 0.1) return;
            const midPoint = new THREE.Vector3().copy(pStart).lerp(pEnd, 0.5);
            const sprite = makeTextSprite(`Corda: ${dist.toFixed(1)}m`, '#ffdd59', 'rgba(50, 50, 0, 0.8)'); sprite.position.copy(midPoint); scene.add(sprite); textSprites.push(sprite);
        }

        function drawAntenna() {
            antennaMeshes.forEach(m => scene.remove(m)); antennaMeshes = [];
            markerMeshes.forEach(m => scene.remove(m)); markerMeshes = [];
            textSprites.forEach(m => scene.remove(m)); textSprites = [];
            document.getElementById('warning').style.display = 'none';

            if (!point1.visible || !point2.visible) return;
            
            const A = point1.position; const B = point2.position;
            const totalDist = A.distanceTo(B);
            const dir = new THREE.Vector3().subVectors(B, A).normalize();
            
            drawDropLine(A, 0xff4757, `Alb.A: ${(A.y - groundLevel).toFixed(1)}m`);
            drawDropLine(B, 0x1e90ff, `Alb.B: ${(B.y - groundLevel).toFixed(1)}m`);

            const type = document.getElementById('antType').value;
            if (type === 'none') { drawRopeLabel(A, B); return; }

            let wireLength = 0; const copperColor = 0xe67e22;

            if (type === 'dipole') {
                const band = parseFloat(document.getElementById('dipoleBand').value);
                wireLength = band / 2; const armLen = wireLength / 2;
                if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                const Center = new THREE.Vector3().copy(A).lerp(B, 0.5);
                const p1 = new THREE.Vector3().copy(Center).add(dir.clone().multiplyScalar(-armLen));
                const p2 = new THREE.Vector3().copy(Center).add(dir.clone().multiplyScalar(armLen));
                
                buildWire(p1, Center, copperColor); buildWire(Center, p2, copperColor);
                let balun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                balun.position.copy(Center); scene.add(balun); markerMeshes.push(balun);
                
                drawDropLine(Center, 0x00ffff, `Feed: ${(Center.y - groundLevel).toFixed(1)}m`);
                drawRopeLabel(A, p1); drawRopeLabel(p2, B);

            } else if (type === 'endfed') {
                const startNode = document.getElementById('efStart').value === 'A' ? A : B;
                const activeDir = document.getElementById('efStart').value === 'A' ? dir.clone() : dir.clone().multiplyScalar(-1);
                const dist = parseFloat(document.getElementById('efDist').value);
                const L1 = parseFloat(document.getElementById('efL1').value);
                const L2 = parseFloat(document.getElementById('efL2').value);
                wireLength = dist + L1 + L2;
                if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                const pStartWire = new THREE.Vector3().copy(startNode).add(activeDir.clone().multiplyScalar(dist));
                const pFeed = new THREE.Vector3().copy(pStartWire).add(activeDir.clone().multiplyScalar(L1));
                const pEndWire = new THREE.Vector3().copy(pFeed).add(activeDir.clone().multiplyScalar(L2));
                
                buildWire(pStartWire, pFeed, copperColor); buildWire(pFeed, pEndWire, copperColor);
                let balun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), new THREE.MeshBasicMaterial({color: 0x2ed573}));
                balun.position.copy(pFeed); scene.add(balun); markerMeshes.push(balun);
                
                drawDropLine(pFeed, 0x2ed573, `Feed: ${(pFeed.y - groundLevel).toFixed(1)}m`);
                if (document.getElementById('efStart').value === 'A') { drawRopeLabel(A, pStartWire); drawRopeLabel(pEndWire, B); }
                else { drawRopeLabel(B, pStartWire); drawRopeLabel(pEndWire, A); }

            } else if (type === 'longwire') {
                const startNode = document.getElementById('lwStart').value === 'A' ? A : B;
                const activeDir = document.getElementById('lwStart').value === 'A' ? dir.clone() : dir.clone().multiplyScalar(-1);
                const L = parseFloat(document.getElementById('lwLen').value);
                if (L > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                const pEndWire = new THREE.Vector3().copy(startNode).add(activeDir.clone().multiplyScalar(L));
                
                buildWire(startNode, pEndWire, copperColor);
                let balun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), new THREE.MeshBasicMaterial({color: 0xffdd59}));
                balun.position.copy(startNode); scene.add(balun); markerMeshes.push(balun);
                
                drawDropLine(startNode, 0xffdd59, `Feed: ${(startNode.y - groundLevel).toFixed(1)}m`);
                if (document.getElementById('lwStart').value === 'A') { drawRopeLabel(pEndWire, B); }
                else { drawRopeLabel(pEndWire, A); }
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); }
        function animate() { renderer.setAnimationLoop( render ); }

        function render( timestamp, frame ) {
            if ( frame ) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                // Dimensione adattiva per pallini E quadrati
                const apparentSizeFactor = 0.05; 
                if (point1.visible) point1.scale.setScalar(camera.position.distanceTo(point1.position) * apparentSizeFactor);
                if (point2.visible) point2.scale.setScalar(camera.position.distanceTo(point2.position) * apparentSizeFactor);
                
                // Magia dei Quadrati: Restano sempre visibili come dimensione, ma fissi nello spazio!
                if (activePlane1.visible) activePlane1.scale.setScalar(camera.position.distanceTo(activePlane1.position) * 0.15);
                if (activePlane2.visible) activePlane2.scale.setScalar(camera.position.distanceTo(activePlane2.position) * 0.15);

                markerMeshes.forEach(marker => marker.scale.setScalar(camera.position.distanceTo(marker.position) * apparentSizeFactor));
                
                textSprites.forEach(sprite => {
                    const dist = camera.position.distanceTo(sprite.position);
                    sprite.scale.set(dist * 0.25, dist * 0.06, 1);
                });

                if ( hitTestSourceRequested === false ) {
                    session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                        session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) { hitTestSource = source; } );
                    } );
                    session.addEventListener( 'end', function () { hitTestSourceRequested = false; hitTestSource = null; } );
                    hitTestSourceRequested = true;
                }

                // Patch anti-tremolio per il mirino base
                if (currentAction.startsWith('PLACE_PLANE')) {
                    const distance = 2; 
                    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                    targetReticlePosition.copy(camera.position).add(camDir.multiplyScalar(distance));
                    targetReticleQuaternion.copy(camera.quaternion); 
                    reticle.position.lerp(targetReticlePosition, 0.3);
                    reticle.quaternion.slerp(targetReticleQuaternion, 0.3);
                    reticle.visible = true; 
                } else {
                    reticle.visible = false;
                }
            }
            renderer.render( scene, camera );
        }
    </script>
</body>
</html>
