<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Ham Radio Planner - Extended Range</title>
    
    <!-- Meta tag per la PWA e collegamento al Manifest -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#2ed573">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; touch-action: none; color: white;}
        
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 100; pointer-events: none; padding: 5px; box-sizing: border-box;
        }

        #top-bar { display: flex; justify-content: space-between; width: 100%; }

        #dataPanel {
            background: rgba(0, 0, 0, 0.85); padding: 10px; border-radius: 8px; font-size: 13px;
            width: fit-content; max-width: 45%; pointer-events: auto; border-left: 3px solid #ffdd59;
        }
        .data-value { font-weight: bold; color: #ffdd59; font-size: 15px; }

        #antennaPanel {
            background: rgba(20, 40, 60, 0.95); padding: 10px; border-radius: 8px; font-size: 14px;
            width: 45%; pointer-events: auto; border: 2px solid #1e90ff; display: none;
        }
        #antennaPanel select, #antennaPanel input { width: 100%; margin-top: 5px; margin-bottom: 10px; padding: 5px; background: #222; color: white; border: 1px solid #555; }
        .ant-settings { display: none; }
        #warning { color: #ff4757; font-weight: bold; font-size: 12px; display: none; margin-top: 5px;}

        .bottom-controls { display: flex; flex-direction: column; align-items: center; gap: 5px; width: 100%; }
        .btn-row { display: flex; gap: 5px; pointer-events: auto; width: 100%; justify-content: center; }
        .main-btn {
            padding: 10px 5px; font-size: 13px; font-weight: bold; flex: 1; border-radius: 8px;
            border: 2px solid transparent; cursor: pointer; color: white; opacity: 0.7; transition: 0.2s;
        }
        .main-btn.active { opacity: 1; border-color: white; transform: scale(1.02); }
        
        #btnGround { background: #2ed573; color: black; }
        #btnA { background: #ff4757; }
        #btnB { background: #1e90ff; }
        #btnC { background: #f1c40f; color: black; }
        #btnPhoto { background: #ffffff; color: black; font-size: 14px; }
        #btnReset { background: #ff9f43; color: black; font-size: 14px; }
        
        #instruction { text-align: center; color: #fff; font-weight: bold; background: #e1b12c; padding: 6px; border-radius: 5px; width: 100%; box-sizing: border-box; font-size: 13px;}
        
        .edit-panel { background: rgba(30,30,30,0.95); padding: 8px; border-radius: 8px; width: 100%; pointer-events: auto; box-sizing: border-box; text-align: center;}
        .edit-row { display: flex; justify-content: center; gap: 10px; margin-top: 5px; }
        .edit-btn { padding: 10px 15px; font-size: 14px; background: #444; color: white; border: 1px solid #777; border-radius: 5px; font-weight: bold; cursor: pointer;}
        .edit-btn:active { background: #888; }
        
        .height-input-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; }
        #phoneHeight { width: 60px; padding: 5px; font-size: 16px; text-align: center; font-weight: bold; border-radius: 4px; border: none;}
        
        #touchArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: -1; }
        
        #photoOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(46, 213, 115, 0.9); color: black; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; display: none; z-index: 200; box-shadow: 0 4px 6px rgba(0,0,0,0.5);}
        
        #btnInfo { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2ed573; color: #2ed573; border-radius: 50%; width: 35px; height: 35px; font-weight: bold; font-size: 18px; cursor: pointer; z-index: 200; pointer-events: auto; display: flex; align-items: center; justify-content: center;}
        
        /* Tasto Settings */
        #btnSettings { position: absolute; top: 10px; right: 55px; background: rgba(0,0,0,0.7); border: 2px solid #1e90ff; color: #1e90ff; border-radius: 50%; width: 35px; height: 35px; font-weight: bold; font-size: 18px; cursor: pointer; z-index: 200; pointer-events: auto; display: flex; align-items: center; justify-content: center;}

        .custom-modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; max-width: 400px; background: rgba(20, 30, 40, 0.98); padding: 20px; border: 2px solid #2ed573; border-radius: 10px; z-index: 300; pointer-events: auto; color: white; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.8);}
        .custom-modal h3 { margin-top: 0; color: #2ed573; }
        .custom-modal p { font-size: 14px; line-height: 1.5; text-align: justify; margin-bottom: 20px; }
        
        #settingsModal { border-color: #1e90ff; }
        #settingsModal h3 { color: #1e90ff; margin-bottom: 20px;}
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-size: 14px; text-align: left;}
        
        /* Nuovi controlli + e - per evitare la tastiera e slider buggati in AR */
        .stepper { display: flex; align-items: center; gap: 10px; }
        .step-btn { background: #444; color: white; border: 1px solid #777; width: 35px; height: 35px; border-radius: 5px; font-size: 20px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .step-btn:active { background: #1e90ff; color: white; border-color: white;}
        .stepper span { width: 60px; text-align: center; font-weight: bold; font-size: 16px; color: #ffdd59;}

        .modal-close-btn { padding: 10px 20px; background: #2ed573; color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px; width: 100%; margin-top: 10px;}
        #btnCloseSettings { background: #1e90ff; color: white; }
    </style>
</head>
<body>

    <div id="ui-container" style="display: none;">
        <div id="touchArea"></div>
        
        <!-- Tasti in alto a destra -->
        <button id="btnInfo">i</button>
        <button id="btnSettings">‚öôÔ∏è</button>

        <!-- Pannello Info Modal -->
        <div id="infoModal" class="custom-modal">
            <h3>Info Privacy & Offline</h3>
            <p>Questa app √® progettata per i radioamatori: <strong>non raccoglie dati personali</strong> e salva i file essenziali sul tuo dispositivo per funzionare perfettamente al 100% in modalit√† offline, anche dove non c'√® copertura di rete.</p>
            <p style="font-size: 13px; color: #ffdd59; margin-top: -10px;">‚ö†Ô∏è <strong>Requisiti:</strong> Per funzionare, richiede un browser compatibile con la Realt√† Aumentata (WebXR), come <strong>Google Chrome</strong> (consigliato su Android) o browser abilitati su iOS.</p>
            <button id="btnCloseInfo" class="modal-close-btn">Ho capito</button>
        </div>

        <!-- Pannello Settings Modal (Riprogettato senza Input) -->
        <div id="settingsModal" class="custom-modal">
            <h3>Impostazioni Visive</h3>
            
            <div class="setting-row">
                <label>Lato Griglia:</label>
                <div class="stepper">
                    <button id="btnGridMinus" class="step-btn">-</button>
                    <span id="gridVal">50m</span>
                    <button id="btnGridPlus" class="step-btn">+</button>
                </div>
            </div>
            
            <div class="setting-row">
                <label>Grandezza Punti:</label>
                <div class="stepper">
                    <button id="btnPtMinus" class="step-btn">-</button>
                    <span id="ptVal">100%</span>
                    <button id="btnPtPlus" class="step-btn">+</button>
                </div>
            </div>
            
            <button id="btnCloseSettings" class="modal-close-btn">Chiudi</button>
        </div>
        
        <div id="top-bar">
            <div id="dataPanel">
                <strong>QUOTE (dal suolo):</strong><br>
                A: <span id="hA" class="data-value">--</span>m<br>
                B: <span id="hB" class="data-value">--</span>m<br>
                C: <span id="hC" class="data-value" style="color:#f1c40f;">--</span>m<br>
                <hr style="border-color:#555; margin: 5px 0;">
                Spazio Totale:<br><span id="distAB" class="data-value" style="font-size: 18px;">--</span>m
                <div id="distV_container" style="display:none; font-size:11px; margin-top:3px; color:#ccc; word-wrap: break-word;">
                    A-C: <span id="distAC">--</span>m | C-B: <span id="distCB">--</span>m
                </div>
            </div>

            <div id="antennaPanel">
                <strong>Configura Antenna</strong>
                <select id="antType">
                    <option value="none">Solo Filo</option>
                    <option value="dipole">Dipolo</option>
                    <option value="endfed">End Fed</option>
                    <option value="longwire">Long Wire</option>
                </select>

                <div id="setDipole" class="ant-settings">
                    Banda:<br>
                    <select id="dipoleBand">
                        <option value="160">160m (~80m filo)</option>
                        <option value="80">80m (~40m filo)</option>
                        <option value="40">40m (~20m filo)</option>
                        <option value="20">20m (~10m filo)</option>
                        <option value="15">15m (~7m filo)</option>
                        <option value="10">10m (~5m filo)</option>
                        <option value="6">6m (~3m filo)</option>
                        <option value="4">4m (~2m filo)</option>
                        <option value="2">2m (~1m filo)</option>
                    </select>
                </div>

                <div id="setEndFed" class="ant-settings">
                    Start:<br>
                    <select id="efStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
                    Corda Tirante (m): <input type="number" id="efDist" value="1" step="0.5">
                    L1 (m): <input type="number" id="efL1" value="10" step="0.5">
                    L2 (m): <input type="number" id="efL2" value="2" step="0.5">
                </div>

                <div id="setLongWire" class="ant-settings">
                    Start:<br>
                    <select id="lwStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
                    Lunghezza (m): <input type="number" id="lwLen" value="20" step="1">
                </div>
                
                <div id="warning">‚ö†Ô∏è Antenna pi√π lunga dello spazio!</div>
            </div>
        </div>

        <div class="bottom-controls">
            
            <div id="panel-setup-ground" class="edit-panel" style="display: none;">
                <div style="font-size: 13px; margin-bottom: 8px; color: #2ed573;">CALIBRAZIONE MATEMATICA (Supera Limiti AR)</div>
                <div class="height-input-container">
                    Altezza cellulare: <input type="number" id="phoneHeight" value="1.40" step="0.05"> m
                </div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnSetByHeight" style="background:#2ed573; color:black;">Usa Altezza Cellulare</button>
                    <button class="edit-btn" id="btnSetByTouch">Usa 3 Tocchi (Limita a 5m)</button>
                </div>
            </div>

            <div id="panel-edit-point" class="edit-panel" style="display: none;">
                <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">üëÜ TRASCINA SU/GI√ô per alzare.</div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnMoveBase">Sposta Base üéØ</button>
                    <button class="edit-btn" id="btnDoneEdit" style="background: #2ed573; color: black;">‚úî OK</button>
                </div>
            </div>

            <div id="instruction">Inizializzazione...</div>

            <div class="btn-row">
                <button id="btnGround" class="main-btn">1. Zero</button>
                <button id="btnA" class="main-btn">2. Alb.A</button>
                <button id="btnB" class="main-btn">3. Alb.B</button>
                <button id="btnC" class="main-btn">4. C (Opz)</button>
            </div>
            
            <div class="btn-row">
                <button id="btnReset" class="main-btn">üîÑ Reset Totale</button>
                <button id="btnPhoto" class="main-btn">üì∏ Fai Foto</button>
            </div>
        </div>
    </div>
    
    <div id="photoOverlay">Usa i tasti screenshot! (Torno tra 5s)</div>

    <!-- Mappa di importazione con link esterni per evitare di scaricare file locali in cartelle -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let container, camera, scene, renderer, controller, reticle;
        let hitTestSource = null, hitTestSourceRequested = false;

        let point1, point2, point3, groundGrid, lineAB;
        let antennaMeshes = []; 
        let markerMeshes = []; 
        let textSprites = []; 
        
        let groundLevel = 0; 
        let isGroundSet = false;
        let groundCalibrationPoints = []; 
        let tempGroundMarkers = [];
        
        let currentAction = 'NONE'; 

        let lastTouchY = 0;
        let isDragging = false, hasDragged = false; 

        // Nuove variabili per le impostazioni
        let globalGridSize = 50;
        let globalPointScale = 0.1; // Default equivale al 100%

        function disposeNode(node) {
            if (!node) return;
            scene.remove(node);
            if (node.geometry) node.geometry.dispose();
            if (node.material) {
                if (Array.isArray(node.material)) {
                    node.material.forEach(m => {
                        if (m.map) m.map.dispose();
                        m.dispose();
                    });
                } else {
                    if (node.material.map) node.material.map.dispose();
                    node.material.dispose();
                }
            }
        }

        init();
        animate();

        function init() {
            container = document.createElement( 'div' );
            document.body.appendChild( container );
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 200 );

            const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );
            light.position.set( 0.5, 1, 0.25 ); scene.add( light );

            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.xr.enabled = true;
            container.appendChild( renderer.domElement );

            document.body.appendChild( ARButton.createButton( renderer, { 
                requiredFeatures: [ 'hit-test', 'dom-overlay' ],
                optionalFeatures: [ 'depth-sensing' ],
                depthSensing: {
                    usagePreference: [ 'cpu-optimized', 'gpu-optimized' ],
                    dataFormatPreference: [ 'luminance-alpha', 'float32' ]
                },
                domOverlay: { root: document.getElementById('ui-container') }
            } ) );

            // Griglia Iniziale con quadrati fissi a 0.5m
            groundGrid = new THREE.GridHelper( globalGridSize, Math.round(globalGridSize * 2), 0x2ed573, 0x2ed573 );
            groundGrid.material.opacity = 0.8; groundGrid.material.transparent = true; groundGrid.visible = false;
            scene.add( groundGrid );

            // Creazione punti base
            const pointGeo = new THREE.SphereGeometry( 0.1, 32, 32 );
            point1 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0xff4757 } ) ); point1.visible = false; scene.add( point1 );
            point2 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0x1e90ff } ) ); point2.visible = false; scene.add( point2 );
            point3 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0xf1c40f } ) ); point3.visible = false; scene.add( point3 );

            lineAB = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: 0xffdd59, linewidth: 1, transparent: true, opacity: 0.5 }));
            lineAB.visible = false; scene.add(lineAB);

            reticle = new THREE.Mesh( new THREE.RingGeometry( 0.05, 0.08, 32 ).rotateX( - Math.PI / 2 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
            reticle.matrixAutoUpdate = true; reticle.visible = false; scene.add( reticle );

            controller = renderer.xr.getController( 0 );
            controller.addEventListener( 'select', onSelect );
            scene.add( controller );

            window.addEventListener( 'resize', onWindowResize );

            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ui-container').style.display = 'flex';
                setAction('MENU_GROUND');
            });

            document.getElementById('ui-container').addEventListener('beforexrselect', (ev) => {
                if (ev.target.id !== 'touchArea') ev.preventDefault();
            });

            document.getElementById('btnGround').addEventListener('click', () => setAction('MENU_GROUND'));
            
            // Gestione Tasto Info e Settings
            document.getElementById('btnInfo').addEventListener('click', () => { document.getElementById('infoModal').style.display = 'block'; });
            document.getElementById('btnCloseInfo').addEventListener('click', () => { document.getElementById('infoModal').style.display = 'none'; });
            
            document.getElementById('btnSettings').addEventListener('click', () => { document.getElementById('settingsModal').style.display = 'block'; });
            document.getElementById('btnCloseSettings').addEventListener('click', () => { document.getElementById('settingsModal').style.display = 'none'; });

            // GESTIONE DINAMICA DELLE IMPOSTAZIONI TRAMITE PULSANTI (+ / -)
            function updateGridVisuals() {
                document.getElementById('gridVal').innerText = globalGridSize + 'm';
                scene.remove(groundGrid);
                groundGrid = new THREE.GridHelper( globalGridSize, Math.round(globalGridSize * 2), 0x2ed573, 0x2ed573 );
                groundGrid.material.opacity = 0.8; 
                groundGrid.material.transparent = true;
                if (isGroundSet) {
                    groundGrid.position.set(camera.position.x, groundLevel, camera.position.z);
                    groundGrid.visible = true;
                } else {
                    groundGrid.visible = false;
                }
                scene.add( groundGrid );
            }

            document.getElementById('btnGridMinus').addEventListener('click', () => {
                if (globalGridSize > 10) { globalGridSize -= 10; updateGridVisuals(); }
            });
            document.getElementById('btnGridPlus').addEventListener('click', () => {
                if (globalGridSize < 150) { globalGridSize += 10; updateGridVisuals(); }
            });

            document.getElementById('btnPtMinus').addEventListener('click', () => {
                if (globalPointScale > 0.04) { 
                    globalPointScale -= 0.02; 
                    document.getElementById('ptVal').innerText = Math.round(globalPointScale * 1000) + '%'; 
                }
            });
            document.getElementById('btnPtPlus').addEventListener('click', () => {
                if (globalPointScale < 0.3) { 
                    globalPointScale += 0.02; 
                    document.getElementById('ptVal').innerText = Math.round(globalPointScale * 1000) + '%'; 
                }
            });
            
            document.getElementById('btnSetByHeight').addEventListener('click', () => {
                const height = parseFloat(document.getElementById('phoneHeight').value);
                if(isNaN(height) || height <= 0) return;
                groundLevel = camera.position.y - height;
                groundGrid.position.set(camera.position.x, groundLevel, camera.position.z);
                groundGrid.visible = true; isGroundSet = true;
                setAction('NONE'); updateCalculations(); drawAntenna();
            });

            document.getElementById('btnSetByTouch').addEventListener('click', () => setAction('PLACE_GROUND'));
            document.getElementById('btnA').addEventListener('click', () => setAction('PLACE_BASE_A'));
            document.getElementById('btnB').addEventListener('click', () => setAction('PLACE_BASE_B'));
            document.getElementById('btnC').addEventListener('click', () => setAction('PLACE_BASE_C'));
            
            // Nuovi Event Listener per Spostare la Base dinamicamente
            document.getElementById('btnMoveBase').addEventListener('click', () => {
                if (currentAction === 'SET_HEIGHT_A') setAction('MOVE_BASE_A');
                else if (currentAction === 'SET_HEIGHT_B') setAction('MOVE_BASE_B');
                else if (currentAction === 'SET_HEIGHT_C') setAction('MOVE_BASE_C');
            });
            document.getElementById('btnDoneEdit').addEventListener('click', () => setAction('NONE'));

            document.getElementById('antType').addEventListener('change', updateAntennaUI);
            document.querySelectorAll('#antennaPanel select, #antennaPanel input').forEach(el => el.addEventListener('input', drawAntenna));

            document.getElementById('btnPhoto').addEventListener('click', () => {
                document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'hidden');
                document.getElementById('antennaPanel').style.visibility = 'hidden';
                const toast = document.getElementById('photoOverlay');
                toast.style.display = 'block';
                setTimeout(() => {
                    toast.style.display = 'none';
                    document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'visible');
                    if (point1.visible && point2.visible) document.getElementById('antennaPanel').style.visibility = 'visible';
                }, 5000);
            });

            document.getElementById('btnReset').addEventListener('click', () => {
                point1.visible = false;
                point2.visible = false;
                point3.visible = false;
                groundGrid.visible = false;
                lineAB.visible = false;

                antennaMeshes.forEach(m => disposeNode(m)); antennaMeshes = [];
                markerMeshes.forEach(m => disposeNode(m)); markerMeshes = [];
                textSprites.forEach(m => disposeNode(m)); textSprites = [];
                clearTempMarkers();

                isGroundSet = false;
                groundLevel = 0;

                document.getElementById('hA').innerText = '--';
                document.getElementById('hB').innerText = '--';
                document.getElementById('hC').innerText = '--';
                document.getElementById('distAB').innerText = '--';
                document.getElementById('distV_container').style.display = 'none';
                
                document.getElementById('antennaPanel').style.display = 'none';
                document.getElementById('warning').style.display = 'none';

                setAction('MENU_GROUND');
            });

            const touchArea = document.getElementById('touchArea');
            touchArea.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1 && (currentAction === 'SET_HEIGHT_A' || currentAction === 'SET_HEIGHT_B' || currentAction === 'SET_HEIGHT_C')) {
                    isDragging = true; hasDragged = false; 
                    lastTouchY = e.touches[0].clientY;
                }
            });

            touchArea.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                hasDragged = true; 
                if (e.touches.length === 1 && (currentAction === 'SET_HEIGHT_A' || currentAction === 'SET_HEIGHT_B' || currentAction === 'SET_HEIGHT_C')) {
                    let pt = currentAction === 'SET_HEIGHT_A' ? point1 : (currentAction === 'SET_HEIGHT_B' ? point2 : point3);
                    if (!pt || !pt.visible) return;

                    let touchY = e.touches[0].clientY;
                    let deltaY = lastTouchY - touchY; 
                    
                    let dist = camera.position.distanceTo(pt.position);
                    let vFov = camera.fov * Math.PI / 180; 
                    let visibleHeight = 2 * Math.tan(vFov / 2) * dist;
                    let sensitivity = visibleHeight / window.innerHeight; 

                    pt.position.y += deltaY * sensitivity;

                    if (isGroundSet && pt.position.y < groundLevel) pt.position.y = groundLevel;

                    lastTouchY = touchY;
                    updateCalculations();
                    drawAntenna(); 
                }
            });
            touchArea.addEventListener('touchend', () => { isDragging = false; });
        }

        function setAction(action) {
            currentAction = action;
            document.getElementById('panel-setup-ground').style.display = 'none';
            document.getElementById('panel-edit-point').style.display = 'none';
            document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));

            let inst = document.getElementById('instruction');

            if (action === 'MENU_GROUND') {
                document.getElementById('btnGround').classList.add('active');
                document.getElementById('panel-setup-ground').style.display = 'block';
                inst.innerText = "Scegli come impostare la quota zero del suolo."; inst.style.background = "#2ed573";
            } else if (action === 'PLACE_GROUND') {
                groundCalibrationPoints = []; clearTempMarkers();
                document.getElementById('btnGround').classList.add('active');
                inst.innerText = "Tocca 3 punti a terra per calibrare lo Zero."; inst.style.background = "#2ed573";
            } else if (action === 'PLACE_BASE_A' || action === 'PLACE_BASE_B' || action === 'PLACE_BASE_C') {
                const btn = action === 'PLACE_BASE_A' ? 'btnA' : (action === 'PLACE_BASE_B' ? 'btnB' : 'btnC');
                document.getElementById(btn).classList.add('active');
                inst.innerText = action === 'PLACE_BASE_C' ? "MIRA al terreno per il CENTRO e TOCCA." : "MIRA al terreno per posizionare la BASE e TOCCA."; 
                inst.style.background = action === 'PLACE_BASE_A' ? "#ff4757" : (action === 'PLACE_BASE_B' ? "#1e90ff" : "#f1c40f");
            } else if (action === 'SET_HEIGHT_A' || action === 'SET_HEIGHT_B' || action === 'SET_HEIGHT_C') {
                const btn = action === 'SET_HEIGHT_A' ? 'btnA' : (action === 'SET_HEIGHT_B' ? 'btnB' : 'btnC');
                document.getElementById(btn).classList.add('active');
                document.getElementById('panel-edit-point').style.display = 'block';
                inst.innerText = "2. TRASCINA SU/GI√ô per alzare il punto."; 
                inst.style.background = action === 'SET_HEIGHT_A' ? "#ff4757" : (action === 'SET_HEIGHT_B' ? "#1e90ff" : "#f1c40f");
            } else if (action === 'MOVE_BASE_A' || action === 'MOVE_BASE_B' || action === 'MOVE_BASE_C') {
                const btn = action === 'MOVE_BASE_A' ? 'btnA' : (action === 'MOVE_BASE_B' ? 'btnB' : 'btnC');
                document.getElementById(btn).classList.add('active');
                inst.innerText = "MIRA al terreno per spostare la base e TOCCA per confermare."; 
                inst.style.background = action === 'MOVE_BASE_A' ? "#ff4757" : (action === 'MOVE_BASE_B' ? "#1e90ff" : "#f1c40f");
            } else {
                inst.innerText = "Punti posizionati. Puoi personalizzare l'Antenna."; inst.style.background = "#555";
            }
        }

        function makeTextSprite(message, textColor = '#ffffff', bgColor = 'rgba(0, 0, 0, 0.7)', isVertical = false) {
            const canvas = document.createElement('canvas');
            if (isVertical) {
                canvas.width = 128; canvas.height = 512;
            } else {
                canvas.width = 512; canvas.height = 128;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            if (isVertical) {
                ctx.translate(64, 256);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(message, 0, 0);
            } else {
                ctx.fillText(message, 256, 64);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.userData.isVertical = isVertical; 
            return sprite;
        }

        function drawDropLine(position, color, labelText) {
            if (!isGroundSet) return;
            const groundPos = new THREE.Vector3(position.x, groundLevel, position.z);
            const geo = new THREE.BufferGeometry().setFromPoints([position, groundPos]);
            const mat = new THREE.LineDashedMaterial({ color: color, dashSize: 0.2, gapSize: 0.2 });
            const line = new THREE.Line(geo, mat);
            line.computeLineDistances();
            scene.add(line); antennaMeshes.push(line);

            const labelY = groundLevel + (position.y - groundLevel) * 0.5;
            const sprite = makeTextSprite(labelText, `#${color.toString(16).padStart(6, '0')}`, 'rgba(0,0,0,0.7)', true);
            sprite.position.set(position.x, labelY, position.z);
            scene.add(sprite); textSprites.push(sprite);
        }

        function drawRopeLabel(pStart, pEnd) {
            const dist = pStart.distanceTo(pEnd);
            if (dist < 0.1) return;
            const midPoint = new THREE.Vector3().copy(pStart).lerp(pEnd, 0.5);
            const sprite = makeTextSprite(`Corda: ${dist.toFixed(1)}m`, '#ffdd59', 'rgba(50, 50, 0, 0.8)', false);
            sprite.position.copy(midPoint);
            scene.add(sprite); textSprites.push(sprite);
        }

        function onSelect() {
            if (hasDragged) { hasDragged = false; return; }

            if (currentAction === 'PLACE_GROUND') {
                if(!reticle.visible) return;
                groundCalibrationPoints.push(reticle.position.y);
                let marker = new THREE.Mesh( new THREE.SphereGeometry(0.02), new THREE.MeshBasicMaterial({color: 0xffff00}) );
                marker.position.copy(reticle.position); scene.add(marker); tempGroundMarkers.push(marker);
                if (groundCalibrationPoints.length === 3) {
                    groundLevel = groundCalibrationPoints.reduce((a, b) => a + b, 0) / 3;
                    groundGrid.position.set(reticle.position.x, groundLevel, reticle.position.z);
                    groundGrid.visible = true; isGroundSet = true; clearTempMarkers(); setAction('NONE'); updateCalculations(); drawAntenna();
                }
            } else if (currentAction === 'PLACE_BASE_A' || currentAction === 'PLACE_BASE_B' || currentAction === 'PLACE_BASE_C') {
                if (reticle.visible) {
                    // Auto-Imposta la Quota Zero se l'utente non l'ha fatto prima
                    if (!isGroundSet) {
                        groundLevel = reticle.position.y;
                        groundGrid.position.set(camera.position.x, groundLevel, camera.position.z);
                        groundGrid.visible = true; isGroundSet = true;
                    }

                    if (currentAction === 'PLACE_BASE_A') {
                        point1.position.copy(reticle.position);
                        point1.visible = true;
                        setAction('SET_HEIGHT_A');
                    } else if (currentAction === 'PLACE_BASE_B') {
                        point2.position.copy(reticle.position);
                        point2.visible = true;
                        setAction('SET_HEIGHT_B');
                    } else if (currentAction === 'PLACE_BASE_C') {
                        point3.position.copy(reticle.position);
                        point3.visible = true;
                        setAction('SET_HEIGHT_C');
                    }
                    updateCalculations();
                    drawAntenna(); 
                }
            } else if (currentAction === 'MOVE_BASE_A') {
                setAction('SET_HEIGHT_A'); // Conferma lo spostamento
            } else if (currentAction === 'MOVE_BASE_B') {
                setAction('SET_HEIGHT_B');
            } else if (currentAction === 'MOVE_BASE_C') {
                setAction('SET_HEIGHT_C');
            }
        }

        function clearTempMarkers() { 
            tempGroundMarkers.forEach(m => disposeNode(m)); 
            tempGroundMarkers = []; 
        }

        function adjustDepth(amount) {
            let pt = currentAction === 'SET_HEIGHT_A' ? point1 : (currentAction === 'SET_HEIGHT_B' ? point2 : (currentAction === 'SET_HEIGHT_C' ? point3 : null));
            if (!pt || !pt.visible) return;
            
            const toPoint = new THREE.Vector3().subVectors(pt.position, camera.position);
            toPoint.y = 0; toPoint.normalize();
            pt.position.add(toPoint.clone().multiplyScalar(amount));
            
            updateCalculations();
            drawAntenna();
        }

        function updateCalculations() {
            if (isGroundSet && point1.visible) document.getElementById('hA').innerText = (point1.position.y - groundLevel).toFixed(1);
            if (isGroundSet && point2.visible) document.getElementById('hB').innerText = (point2.position.y - groundLevel).toFixed(1);
            if (isGroundSet && point3.visible) document.getElementById('hC').innerText = (point3.position.y - groundLevel).toFixed(1);
            
            if (point1.visible && point2.visible) {
                let distAB = point1.position.distanceTo(point2.position);
                
                if (point3.visible) {
                    let distAC = point1.position.distanceTo(point3.position);
                    let distCB = point3.position.distanceTo(point2.position);
                    document.getElementById('distAB').innerText = (distAC + distCB).toFixed(1);
                    document.getElementById('distV_container').style.display = 'block';
                    document.getElementById('distAC').innerText = distAC.toFixed(1);
                    document.getElementById('distCB').innerText = distCB.toFixed(1);
                } else {
                    document.getElementById('distAB').innerText = distAB.toFixed(1);
                    document.getElementById('distV_container').style.display = 'none';
                }
                
                document.getElementById('antennaPanel').style.display = 'block';
            }
        }

        function updateAntennaUI() {
            const type = document.getElementById('antType').value;
            document.querySelectorAll('.ant-settings').forEach(el => el.style.display = 'none');
            if (type === 'dipole') document.getElementById('setDipole').style.display = 'block';
            if (type === 'endfed') document.getElementById('setEndFed').style.display = 'block';
            if (type === 'longwire') document.getElementById('setLongWire').style.display = 'block';
            drawAntenna();
        }

        function buildWire(pStart, pEnd, color, thickness=0.015) {
            const dist = pStart.distanceTo(pEnd);
            if (dist < 0.01) return; 
            
            const cylinder = new THREE.Mesh( new THREE.CylinderGeometry(thickness, thickness, dist, 8), new THREE.MeshBasicMaterial({color: color}) );
            cylinder.position.copy(pStart).lerp(pEnd, 0.5);
            cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(pEnd, pStart).normalize());
            scene.add(cylinder); antennaMeshes.push(cylinder);
        }

        function getPointAlongPath(distance, points) {
            let currentDist = 0;
            for (let i = 0; i < points.length - 1; i++) {
                let segLen = points[i].distanceTo(points[i+1]);
                if (segLen < 0.001) continue; 
                
                if (currentDist + segLen >= distance - 0.001) {
                    let excess = Math.max(0, distance - currentDist);
                    let dir = new THREE.Vector3().subVectors(points[i+1], points[i]).normalize();
                    return new THREE.Vector3().copy(points[i]).add(dir.multiplyScalar(excess));
                }
                currentDist += segLen;
            }
            return new THREE.Vector3().copy(points[points.length - 1]);
        }

        function buildWirePath(startDist, endDist, pathPoints, color) {
            let pStart = getPointAlongPath(startDist, pathPoints);
            let pEnd = getPointAlongPath(endDist, pathPoints);

            if (pathPoints.length === 2) {
                buildWire(pStart, pEnd, color); return;
            }

            let C = pathPoints[1];
            let distToC = pathPoints[0].distanceTo(C);

            if (endDist <= distToC + 0.01) {
                buildWire(pStart, pEnd, color); 
            } else if (startDist >= distToC - 0.01) {
                buildWire(pStart, pEnd, color); 
            } else {
                buildWire(pStart, C, color); 
                buildWire(C, pEnd, color);
            }
        }

        function drawAntenna() {
            antennaMeshes.forEach(m => disposeNode(m)); antennaMeshes = [];
            markerMeshes.forEach(m => disposeNode(m)); markerMeshes = [];
            textSprites.forEach(m => disposeNode(m)); textSprites = [];
            document.getElementById('warning').style.display = 'none';

            if (!point1.visible || !point2.visible) {
                lineAB.visible = false;
                return;
            }

            if (point1.visible) drawDropLine(point1.position, 0xff4757, `Alb.A: ${(point1.position.y - groundLevel).toFixed(1)}m`);
            if (point2.visible) drawDropLine(point2.position, 0x1e90ff, `Alb.B: ${(point2.position.y - groundLevel).toFixed(1)}m`);
            if (point3.visible) drawDropLine(point3.position, 0xf1c40f, `Centro: ${(point3.position.y - groundLevel).toFixed(1)}m`);

            const A = point1.position; const B = point2.position;
            const C = point3.visible ? point3.position : null;
            const pathBase = C ? [A, C, B] : [A, B];
            
            let totalDist = C ? A.distanceTo(C) + C.distanceTo(B) : A.distanceTo(B);
            
            if (totalDist < 0.1) {
                document.getElementById('warning').innerText = "‚ö†Ô∏è Punti troppo vicini tra loro!";
                document.getElementById('warning').style.display = 'block'; 
                return;
            } else {
                document.getElementById('warning').innerText = "‚ö†Ô∏è Antenna pi√π lunga dello spazio!";
            }

            lineAB.geometry.setFromPoints(pathBase);
            lineAB.visible = true;

            const type = document.getElementById('antType').value;
            
            if (type === 'none') {
                if (C) { drawRopeLabel(A, C); drawRopeLabel(C, B); } else { drawRopeLabel(A, B); }
                return;
            }

            const copperColor = 0xe67e22;

            if (type === 'dipole') {
                const band = parseFloat(document.getElementById('dipoleBand').value);
                let wireLength = band / 2; const armLen = wireLength / 2;
                
                const FeedNode = C ? C : new THREE.Vector3().copy(A).lerp(B, 0.5);
                const path1 = [FeedNode, A];
                const path2 = [FeedNode, B];
                
                if (armLen > FeedNode.distanceTo(A) || armLen > FeedNode.distanceTo(B)) { 
                    document.getElementById('warning').style.display = 'block'; return; 
                }
                
                buildWirePath(0, armLen, path1, copperColor);
                buildWirePath(0, armLen, path2, copperColor);
                
                let balun = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                balun.position.copy(FeedNode); scene.add(balun); markerMeshes.push(balun);
                
                if (!C) drawDropLine(FeedNode, 0x00ffff, `Feed: ${(FeedNode.y - groundLevel).toFixed(1)}m`);
                
                drawRopeLabel(getPointAlongPath(armLen, path1), A); 
                drawRopeLabel(getPointAlongPath(armLen, path2), B);

            } else if (type === 'endfed') {
                const isStartA = document.getElementById('efStart').value === 'A';
                const path = C ? (isStartA ? [A, C, B] : [B, C, A]) : (isStartA ? [A, B] : [B, A]);
                
                const dist = parseFloat(document.getElementById('efDist').value);
                const L1 = parseFloat(document.getElementById('efL1').value);
                const L2 = parseFloat(document.getElementById('efL2').value);
                let wireLength = dist + L1 + L2;
                
                if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                
                const feedDist = dist + L1;
                buildWirePath(dist, feedDist, path, copperColor);
                buildWirePath(feedDist, wireLength, path, copperColor);
                
                let balunPos = getPointAlongPath(feedDist, path);
                let balun = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                balun.position.copy(balunPos); scene.add(balun); markerMeshes.push(balun);
                
                drawDropLine(balunPos, 0x2ed573, `Trafo: ${(balunPos.y - groundLevel).toFixed(1)}m`);
                
                drawRopeLabel(path[0], getPointAlongPath(dist, path));
                drawRopeLabel(getPointAlongPath(wireLength, path), path[path.length - 1]);

            } else if (type === 'longwire') {
                const isStartA = document.getElementById('lwStart').value === 'A';
                const path = C ? (isStartA ? [A, C, B] : [B, C, A]) : (isStartA ? [A, B] : [B, A]);
                const L = parseFloat(document.getElementById('lwLen').value);
                
                if (L > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                
                buildWirePath(0, L, path, copperColor);
                
                let balun = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                balun.position.copy(path[0]); scene.add(balun); markerMeshes.push(balun);
                
                drawRopeLabel(getPointAlongPath(L, path), path[path.length - 1]);
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); }
        function animate() { renderer.setAnimationLoop( render ); }

        function render( timestamp, frame ) {
            if ( frame ) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                // Applicazione dinamica della dimensione dei punti
                const apparentSizeFactor = globalPointScale; 
                if (point1.visible) point1.scale.setScalar(camera.position.distanceTo(point1.position) * apparentSizeFactor);
                if (point2.visible) point2.scale.setScalar(camera.position.distanceTo(point2.position) * apparentSizeFactor);
                if (point3.visible) point3.scale.setScalar(camera.position.distanceTo(point3.position) * apparentSizeFactor);
                markerMeshes.forEach(marker => marker.scale.setScalar(camera.position.distanceTo(marker.position) * apparentSizeFactor));
                
                textSprites.forEach(sprite => {
                    const dist = camera.position.distanceTo(sprite.position);
                    if (sprite.userData.isVertical) {
                        sprite.scale.set(dist * 0.06, dist * 0.25, 1);
                    } else {
                        sprite.scale.set(dist * 0.25, dist * 0.06, 1);
                    }
                });

                if ( hitTestSourceRequested === false ) {
                    session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                        session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) { hitTestSource = source; } );
                    } );
                    session.addEventListener( 'end', function () { hitTestSourceRequested = false; hitTestSource = null; } );
                    hitTestSourceRequested = true;
                }

                let hitFound = false;
                if (currentAction === 'PLACE_GROUND' || currentAction === 'PLACE_BASE_A' || currentAction === 'PLACE_BASE_B' || currentAction === 'PLACE_BASE_C' || currentAction === 'MOVE_BASE_A' || currentAction === 'MOVE_BASE_B' || currentAction === 'MOVE_BASE_C') {
                    
                    // 1. Prova prima il classico sensore ARCore (per distanze ravvicinate)
                    if ( hitTestSource ) {
                        const hitTestResults = frame.getHitTestResults( hitTestSource );
                        if ( hitTestResults.length ) {
                            const pose = hitTestResults[0].getPose( referenceSpace );
                            reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                            reticle.quaternion.set(pose.transform.orientation.x, pose.transform.orientation.y, pose.transform.orientation.z, pose.transform.orientation.w);
                            reticle.visible = true;
                            hitFound = true;
                        }
                    }

                    // 2: IL TRUCCO MATEMATICO (Distanza Infinita)
                    if (!hitFound && isGroundSet && currentAction !== 'PLACE_GROUND') {
                        const cameraDirection = new THREE.Vector3();
                        camera.getWorldDirection(cameraDirection);
                        
                        // Assicuriamoci che l'utente stia guardando un po' verso il basso, non in cielo
                        if (cameraDirection.y < -0.01) { 
                            // Calcola a che distanza il raggio visivo tocca il pavimento (groundLevel)
                            const t = (groundLevel - camera.position.y) / cameraDirection.y;
                            
                            // Mettiamo un limite di sicurezza di 100 metri
                            if (t > 0 && t < 100) { 
                                const hitPoint = new THREE.Vector3().copy(camera.position).add(cameraDirection.multiplyScalar(t));
                                reticle.position.copy(hitPoint);
                                reticle.quaternion.setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2); // Sdraiato per terra
                                reticle.visible = true;
                                hitFound = true;
                            }
                        }
                    }

                    if (hitFound) {
                        // Se siamo in modalit√† spostamento base, aggiorna solo X e Z (non Y)
                        if (currentAction === 'MOVE_BASE_A') {
                            point1.position.x = reticle.position.x;
                            point1.position.z = reticle.position.z;
                            drawAntenna(); updateCalculations();
                        } else if (currentAction === 'MOVE_BASE_B') {
                            point2.position.x = reticle.position.x;
                            point2.position.z = reticle.position.z;
                            drawAntenna(); updateCalculations();
                        } else if (currentAction === 'MOVE_BASE_C') {
                            point3.position.x = reticle.position.x;
                            point3.position.z = reticle.position.z;
                            drawAntenna(); updateCalculations();
                        }
                    } else {
                        reticle.visible = false;
                    }
                } else {
                    reticle.visible = false;
                }
            }
            renderer.render( scene, camera );
        }
    </script>
    
    <!-- Avvio del Service Worker -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Offline Engine Pronto!'))
                    .catch(err => console.log('Errore Service Worker:', err));
            });
        }
    </script>
</body>
</html>
