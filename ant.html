<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Ham Radio Planner - Vertical Quotes & Balun Fix</title>
    
    <!-- Meta tag per la PWA e collegamento al Manifest -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#2ed573">
    <link rel="apple-touch-icon" href="./icon-192.png">

    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; touch-action: none; color: white;}
        
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 100; pointer-events: none; padding: 5px; box-sizing: border-box;
        }

        #top-bar { display: flex; justify-content: space-between; width: 100%; }

        #dataPanel {
            background: rgba(0, 0, 0, 0.85); padding: 10px; border-radius: 8px; font-size: 13px;
            width: fit-content; max-width: 45%; pointer-events: auto; border-left: 3px solid #ffdd59;
        }
        .data-value { font-weight: bold; color: #ffdd59; font-size: 15px; }

        #antennaPanel {
            background: rgba(20, 40, 60, 0.95); padding: 10px; border-radius: 8px; font-size: 14px;
            width: 45%; pointer-events: auto; border: 2px solid #1e90ff; display: none;
        }
        #antennaPanel select, #antennaPanel input { width: 100%; margin-top: 5px; margin-bottom: 10px; padding: 5px; background: #222; color: white; border: 1px solid #555; }
        .ant-settings { display: none; }
        #warning { color: #ff4757; font-weight: bold; font-size: 12px; display: none; margin-top: 5px;}

        .bottom-controls { display: flex; flex-direction: column; align-items: center; gap: 5px; width: 100%; }
        .btn-row { display: flex; gap: 5px; pointer-events: auto; width: 100%; justify-content: center; }
        .main-btn {
            padding: 10px 5px; font-size: 13px; font-weight: bold; flex: 1; border-radius: 8px;
            border: 2px solid transparent; cursor: pointer; color: white; opacity: 0.7; transition: 0.2s;
        }
        .main-btn.active { opacity: 1; border-color: white; transform: scale(1.02); }
        
        #btnGround { background: #2ed573; color: black; }
        #btnA { background: #ff4757; }
        #btnB { background: #1e90ff; }
        #btnPhoto { background: #ffffff; color: black; font-size: 14px; }
        #btnReset { background: #ff9f43; color: black; font-size: 14px; }
        
        #instruction { text-align: center; color: #fff; font-weight: bold; background: #e1b12c; padding: 6px; border-radius: 5px; width: 100%; box-sizing: border-box; font-size: 13px;}
        
        .edit-panel { background: rgba(30,30,30,0.95); padding: 8px; border-radius: 8px; width: 100%; pointer-events: auto; box-sizing: border-box; text-align: center;}
        .edit-row { display: flex; justify-content: center; gap: 10px; margin-top: 5px; }
        .edit-btn { padding: 10px 15px; font-size: 14px; background: #444; color: white; border: 1px solid #777; border-radius: 5px; font-weight: bold; cursor: pointer;}
        .edit-btn:active { background: #888; }
        
        .height-input-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; }
        #phoneHeight { width: 60px; padding: 5px; font-size: 16px; text-align: center; font-weight: bold; border-radius: 4px; border: none;}
        
        #touchArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: -1; }
        
        #photoOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(46, 213, 115, 0.9); color: black; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; display: none; z-index: 200; box-shadow: 0 4px 6px rgba(0,0,0,0.5);}
        
        #btnInfo { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2ed573; color: #2ed573; border-radius: 50%; width: 35px; height: 35px; font-weight: bold; font-size: 18px; cursor: pointer; z-index: 200; pointer-events: auto; display: flex; align-items: center; justify-content: center;}
        #infoModal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; max-width: 400px; background: rgba(20, 30, 40, 0.98); padding: 20px; border: 2px solid #2ed573; border-radius: 10px; z-index: 300; pointer-events: auto; color: white; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.8);}
        #infoModal h3 { margin-top: 0; color: #2ed573; }
        #infoModal p { font-size: 14px; line-height: 1.5; text-align: justify; margin-bottom: 20px; }
        #btnCloseInfo { padding: 10px 20px; background: #2ed573; color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px; }
    </style>
</head>
<body>

    <div id="ui-container" style="display: none;">
        <div id="touchArea"></div>
        
        <!-- Tasto Info -->
        <button id="btnInfo">i</button>

        <!-- Pannello Info Modal -->
        <div id="infoModal">
            <h3>Info Privacy & Offline</h3>
            <p>Questa app √® progettata per i radioamatori: <strong>non raccoglie dati personali</strong> e salva i file essenziali sul tuo dispositivo per funzionare perfettamente al 100% in modalit√† offline, anche dove non c'√® copertura di rete.</p>
            <button id="btnCloseInfo">Ho capito</button>
        </div>
        
        <div id="top-bar">
            <div id="dataPanel">
                <strong>QUOTE (dal suolo):</strong><br>
                A: <span id="hA" class="data-value">--</span>m<br>
                B: <span id="hB" class="data-value">--</span>m<br>
                <hr style="border-color:#555; margin: 5px 0;">
                Distanza A-B:<br><span id="distAB" class="data-value" style="font-size: 18px;">--</span>m
            </div>

            <div id="antennaPanel">
                <strong>Configura Antenna</strong>
                <select id="antType">
                    <option value="none">Solo Filo</option>
                    <option value="dipole">Dipolo</option>
                    <option value="endfed">End Fed</option>
                    <option value="longwire">Long Wire</option>
                </select>

                <div id="setDipole" class="ant-settings">
                    Banda:<br>
                    <select id="dipoleBand">
                        <option value="160">160m (~80m filo)</option>
                        <option value="80">80m (~40m filo)</option>
                        <option value="40">40m (~20m filo)</option>
                        <option value="20">20m (~10m filo)</option>
                        <option value="15">15m (~7m filo)</option>
                        <option value="10">10m (~5m filo)</option>
                        <option value="6">6m (~3m filo)</option>
                        <option value="4">4m (~2m filo)</option>
                        <option value="2">2m (~1m filo)</option>
                    </select>
                </div>

                <div id="setEndFed" class="ant-settings">
                    Start:<br>
                    <select id="efStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
                    Corda Tirante (m): <input type="number" id="efDist" value="1" step="0.5">
                    L1 (m): <input type="number" id="efL1" value="10" step="0.5">
                    L2 (m): <input type="number" id="efL2" value="2" step="0.5">
                </div>

                <div id="setLongWire" class="ant-settings">
                    Start:<br>
                    <select id="lwStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
                    Lunghezza (m): <input type="number" id="lwLen" value="20" step="1">
                </div>
                
                <div id="warning">‚ö†Ô∏è Antenna pi√π lunga dello spazio!</div>
            </div>
        </div>

        <div class="bottom-controls">
            
            <div id="panel-setup-ground" class="edit-panel" style="display: none;">
                <div style="font-size: 13px; margin-bottom: 8px; color: #2ed573;">CALIBRAZIONE MATEMATICA</div>
                <div class="height-input-container">
                    Altezza cellulare: <input type="number" id="phoneHeight" value="1.40" step="0.05"> m
                </div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnSetByHeight" style="background:#2ed573; color:black;">Usa Altezza Cellulare</button>
                    <button class="edit-btn" id="btnSetByTouch">Usa 3 Tocchi (Mirino)</button>
                </div>
            </div>

            <div id="panel-edit-point" class="edit-panel" style="display: none;">
                <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">üëÜ TRASCINA SU/GI√ô per alzare. Usa i tasti per muovere la base.</div>
                <div class="edit-row">
                    <button class="edit-btn" id="btnPFar">Base Lontana ‚ÜóÔ∏è</button>
                    <button class="edit-btn" id="btnPNear">Base Vicina ‚ÜôÔ∏è</button>
                </div>
            </div>

            <div id="instruction">Inizializzazione...</div>

            <div class="btn-row">
                <button id="btnGround" class="main-btn">1. Terreno</button>
                <button id="btnA" class="main-btn">2. Albero A</button>
                <button id="btnB" class="main-btn">3. Albero B</button>
            </div>
            
            <div class="btn-row">
                <button id="btnReset" class="main-btn">üîÑ Reset Totale</button>
                <button id="btnPhoto" class="main-btn">üì∏ Fai Foto</button>
            </div>
        </div>
    </div>
    
    <div id="photoOverlay">Usa i tasti screenshot! (Torno tra 5s)</div>

    <!-- Mappa di importazione con link esterni per evitare di scaricare file locali in cartelle -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let container, camera, scene, renderer, controller, reticle;
        let hitTestSource = null, hitTestSourceRequested = false;

        let point1, point2, groundGrid, lineAB;
        let antennaMeshes = []; 
        let markerMeshes = []; 
        let textSprites = []; 
        
        let groundLevel = 0; 
        let isGroundSet = false;
        let groundCalibrationPoints = []; 
        let tempGroundMarkers = [];
        
        let currentAction = 'NONE'; 

        let lastTouchY = 0;
        let isDragging = false, hasDragged = false; 

        function disposeNode(node) {
            if (!node) return;
            scene.remove(node);
            if (node.geometry) node.geometry.dispose();
            if (node.material) {
                if (Array.isArray(node.material)) {
                    node.material.forEach(m => {
                        if (m.map) m.map.dispose();
                        m.dispose();
                    });
                } else {
                    if (node.material.map) node.material.map.dispose();
                    node.material.dispose();
                }
            }
        }

        init();
        animate();

        function init() {
            container = document.createElement( 'div' );
            document.body.appendChild( container );
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 200 );

            const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );
            light.position.set( 0.5, 1, 0.25 ); scene.add( light );

            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.xr.enabled = true;
            container.appendChild( renderer.domElement );

            document.body.appendChild( ARButton.createButton( renderer, { 
                requiredFeatures: [ 'hit-test', 'dom-overlay' ],
                domOverlay: { root: document.getElementById('ui-container') }
            } ) );

            groundGrid = new THREE.GridHelper( 3, 30, 0x2ed573, 0x2ed573 );
            groundGrid.material.opacity = 0.8; groundGrid.material.transparent = true; groundGrid.visible = false;
            scene.add( groundGrid );

            const pointGeo = new THREE.SphereGeometry( 0.05, 32, 32 );
            point1 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0xff4757 } ) ); point1.visible = false; scene.add( point1 );
            point2 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0x1e90ff } ) ); point2.visible = false; scene.add( point2 );

            lineAB = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: 0xffdd59, linewidth: 1 }));
            lineAB.visible = false; scene.add(lineAB);

            reticle = new THREE.Mesh( new THREE.RingGeometry( 0.02, 0.04, 32 ).rotateX( - Math.PI / 2 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
            reticle.matrixAutoUpdate = true; reticle.visible = false; scene.add( reticle );

            controller = renderer.xr.getController( 0 );
            controller.addEventListener( 'select', onSelect );
            scene.add( controller );

            window.addEventListener( 'resize', onWindowResize );

            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ui-container').style.display = 'flex';
                setAction('MENU_GROUND');
            });

            document.getElementById('ui-container').addEventListener('beforexrselect', (ev) => {
                if (ev.target.id !== 'touchArea') ev.preventDefault();
            });

            document.getElementById('btnGround').addEventListener('click', () => setAction('MENU_GROUND'));
            
            // Gestione Tasto Info
            document.getElementById('btnInfo').addEventListener('click', () => { document.getElementById('infoModal').style.display = 'block'; });
            document.getElementById('btnCloseInfo').addEventListener('click', () => { document.getElementById('infoModal').style.display = 'none'; });
            
            document.getElementById('btnSetByHeight').addEventListener('click', () => {
                const height = parseFloat(document.getElementById('phoneHeight').value);
                if(isNaN(height) || height <= 0) return;
                groundLevel = camera.position.y - height;
                groundGrid.position.set(camera.position.x, groundLevel, camera.position.z);
                groundGrid.visible = true; isGroundSet = true;
                setAction('NONE'); updateCalculations(); drawAntenna();
            });

            document.getElementById('btnSetByTouch').addEventListener('click', () => setAction('PLACE_GROUND'));
            document.getElementById('btnA').addEventListener('click', () => setAction('PLACE_BASE_A'));
            document.getElementById('btnB').addEventListener('click', () => setAction('PLACE_BASE_B'));
            document.getElementById('btnPFar').addEventListener('click', () => adjustDepth(0.5));
            document.getElementById('btnPNear').addEventListener('click', () => adjustDepth(-0.5));
            document.getElementById('antType').addEventListener('change', updateAntennaUI);
            document.querySelectorAll('#antennaPanel select, #antennaPanel input').forEach(el => el.addEventListener('input', drawAntenna));

            document.getElementById('btnPhoto').addEventListener('click', () => {
                document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'hidden');
                document.getElementById('antennaPanel').style.visibility = 'hidden';
                const toast = document.getElementById('photoOverlay');
                toast.style.display = 'block';
                setTimeout(() => {
                    toast.style.display = 'none';
                    document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'visible');
                    if (point1.visible && point2.visible) document.getElementById('antennaPanel').style.visibility = 'visible';
                }, 5000);
            });

            document.getElementById('btnReset').addEventListener('click', () => {
                point1.visible = false;
                point2.visible = false;
                groundGrid.visible = false;
                lineAB.visible = false;

                antennaMeshes.forEach(m => disposeNode(m)); antennaMeshes = [];
                markerMeshes.forEach(m => disposeNode(m)); markerMeshes = [];
                textSprites.forEach(m => disposeNode(m)); textSprites = [];
                clearTempMarkers();

                isGroundSet = false;
                groundLevel = 0;

                document.getElementById('hA').innerText = '--';
                document.getElementById('hB').innerText = '--';
                document.getElementById('distAB').innerText = '--';
                
                document.getElementById('antennaPanel').style.display = 'none';
                document.getElementById('warning').style.display = 'none';

                setAction('MENU_GROUND');
            });

            const touchArea = document.getElementById('touchArea');
            touchArea.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1 && (currentAction === 'SET_HEIGHT_A' || currentAction === 'SET_HEIGHT_B')) {
                    isDragging = true; hasDragged = false; 
                    lastTouchY = e.touches[0].clientY;
                }
            });

            touchArea.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                hasDragged = true; 
                if (e.touches.length === 1 && (currentAction === 'SET_HEIGHT_A' || currentAction === 'SET_HEIGHT_B')) {
                    let pt = currentAction === 'SET_HEIGHT_A' ? point1 : point2;
                    if (!pt || !pt.visible) return;

                    let touchY = e.touches[0].clientY;
                    let deltaY = lastTouchY - touchY; 
                    
                    let dist = camera.position.distanceTo(pt.position);
                    let vFov = camera.fov * Math.PI / 180; 
                    let visibleHeight = 2 * Math.tan(vFov / 2) * dist;
                    let sensitivity = visibleHeight / window.innerHeight; 

                    pt.position.y += deltaY * sensitivity;

                    if (isGroundSet && pt.position.y < groundLevel) pt.position.y = groundLevel;

                    lastTouchY = touchY;
                    updateCalculations();
                    drawAntenna(); 
                }
            });
            touchArea.addEventListener('touchend', () => { isDragging = false; });
        }

        function setAction(action) {
            currentAction = action;
            document.getElementById('panel-setup-ground').style.display = 'none';
            document.getElementById('panel-edit-point').style.display = 'none';
            document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));

            let inst = document.getElementById('instruction');

            if (action === 'MENU_GROUND') {
                document.getElementById('btnGround').classList.add('active');
                document.getElementById('panel-setup-ground').style.display = 'block';
                inst.innerText = "Scegli come impostare la quota zero del suolo."; inst.style.background = "#2ed573";
            } else if (action === 'PLACE_GROUND') {
                groundCalibrationPoints = []; clearTempMarkers();
                document.getElementById('btnGround').classList.add('active');
                inst.innerText = "Tocca 3 punti a terra per calibrare lo Zero."; inst.style.background = "#2ed573";
            } else if (action === 'PLACE_BASE_A' || action === 'PLACE_BASE_B') {
                const btn = action === 'PLACE_BASE_A' ? 'btnA' : 'btnB';
                document.getElementById(btn).classList.add('active');
                inst.innerText = "1. MIRA al terreno per posizionare la BASE e TOCCA."; inst.style.background = action === 'PLACE_BASE_A' ? "#ff4757" : "#1e90ff";
            } else if (action === 'SET_HEIGHT_A' || action === 'SET_HEIGHT_B') {
                const btn = action === 'SET_HEIGHT_A' ? 'btnA' : 'btnB';
                document.getElementById(btn).classList.add('active');
                document.getElementById('panel-edit-point').style.display = 'block';
                inst.innerText = "2. TRASCINA SU/GI√ô per alzare il punto sul palo."; inst.style.background = action === 'SET_HEIGHT_A' ? "#ff4757" : "#1e90ff";
            } else {
                inst.innerText = "Antenna pronta. Usa il tasto Foto per salvare."; inst.style.background = "#555";
            }
        }

        function makeTextSprite(message, textColor = '#ffffff', bgColor = 'rgba(0, 0, 0, 0.7)', isVertical = false) {
            const canvas = document.createElement('canvas');
            if (isVertical) {
                canvas.width = 128; canvas.height = 512;
            } else {
                canvas.width = 512; canvas.height = 128;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            if (isVertical) {
                ctx.translate(64, 256);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(message, 0, 0);
            } else {
                ctx.fillText(message, 256, 64);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.userData.isVertical = isVertical; 
            return sprite;
        }

        function drawDropLine(position, color, labelText) {
            if (!isGroundSet) return;
            const groundPos = new THREE.Vector3(position.x, groundLevel, position.z);
            const geo = new THREE.BufferGeometry().setFromPoints([position, groundPos]);
            const mat = new THREE.LineDashedMaterial({ color: color, dashSize: 0.2, gapSize: 0.2 });
            const line = new THREE.Line(geo, mat);
            line.computeLineDistances();
            scene.add(line); antennaMeshes.push(line);

            const labelY = groundLevel + (position.y - groundLevel) * 0.5;
            const sprite = makeTextSprite(labelText, `#${color.toString(16).padStart(6, '0')}`, 'rgba(0,0,0,0.7)', true);
            sprite.position.set(position.x, labelY, position.z);
            scene.add(sprite); textSprites.push(sprite);
        }

        function drawRopeLabel(pStart, pEnd) {
            const dist = pStart.distanceTo(pEnd);
            if (dist < 0.1) return;
            const midPoint = new THREE.Vector3().copy(pStart).lerp(pEnd, 0.5);
            const sprite = makeTextSprite(`Corda: ${dist.toFixed(1)}m`, '#ffdd59', 'rgba(50, 50, 0, 0.8)', false);
            sprite.position.copy(midPoint);
            scene.add(sprite); textSprites.push(sprite);
        }

        function onSelect() {
            if (hasDragged) { hasDragged = false; return; }

            if (currentAction === 'PLACE_GROUND') {
                if(!reticle.visible) return;
                groundCalibrationPoints.push(reticle.position.y);
                let marker = new THREE.Mesh( new THREE.SphereGeometry(0.02), new THREE.MeshBasicMaterial({color: 0xffff00}) );
                marker.position.copy(reticle.position); scene.add(marker); tempGroundMarkers.push(marker);
                if (groundCalibrationPoints.length === 3) {
                    groundLevel = groundCalibrationPoints.reduce((a, b) => a + b, 0) / 3;
                    groundGrid.position.set(reticle.position.x, groundLevel, reticle.position.z);
                    groundGrid.visible = true; isGroundSet = true; clearTempMarkers(); setAction('NONE'); updateCalculations(); drawAntenna();
                }
            } else if (currentAction === 'PLACE_BASE_A') {
                if (reticle.visible) {
                    point1.position.copy(reticle.position);
                    point1.visible = true;
                    setAction('SET_HEIGHT_A');
                    updateCalculations();
                    drawAntenna(); 
                }
            } else if (currentAction === 'PLACE_BASE_B') {
                if (reticle.visible) {
                    point2.position.copy(reticle.position);
                    point2.visible = true;
                    setAction('SET_HEIGHT_B');
                    updateCalculations();
                    drawAntenna();
                }
            }
        }

        function clearTempMarkers() { 
            tempGroundMarkers.forEach(m => disposeNode(m)); 
            tempGroundMarkers = []; 
        }

        function adjustDepth(amount) {
            let pt = currentAction === 'SET_HEIGHT_A' ? point1 : (currentAction === 'SET_HEIGHT_B' ? point2 : null);
            if (!pt || !pt.visible) return;
            
            const toPoint = new THREE.Vector3().subVectors(pt.position, camera.position);
            toPoint.y = 0; toPoint.normalize();
            pt.position.add(toPoint.clone().multiplyScalar(amount));
            
            updateCalculations();
            drawAntenna();
        }

        function updateCalculations() {
            if (isGroundSet && point1.visible) document.getElementById('hA').innerText = (point1.position.y - groundLevel).toFixed(1);
            if (isGroundSet && point2.visible) document.getElementById('hB').innerText = (point2.position.y - groundLevel).toFixed(1);
            
            if (point1.visible && point2.visible) {
                document.getElementById('distAB').innerText = point1.position.distanceTo(point2.position).toFixed(1);
                document.getElementById('antennaPanel').style.display = 'block';
            }
        }

        function updateAntennaUI() {
            const type = document.getElementById('antType').value;
            document.querySelectorAll('.ant-settings').forEach(el => el.style.display = 'none');
            if (type === 'dipole') document.getElementById('setDipole').style.display = 'block';
            if (type === 'endfed') document.getElementById('setEndFed').style.display = 'block';
            if (type === 'longwire') document.getElementById('setLongWire').style.display = 'block';
            drawAntenna();
        }

        function buildWire(pStart, pEnd, color, thickness=0.015) {
            const dist = pStart.distanceTo(pEnd);
            const cylinder = new THREE.Mesh( new THREE.CylinderGeometry(thickness, thickness, dist, 8), new THREE.MeshBasicMaterial({color: color}) );
            cylinder.position.copy(pStart).lerp(pEnd, 0.5);
            cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(pEnd, pStart).normalize());
            scene.add(cylinder); antennaMeshes.push(cylinder);
        }

        function drawAntenna() {
            antennaMeshes.forEach(m => disposeNode(m)); antennaMeshes = [];
            markerMeshes.forEach(m => disposeNode(m)); markerMeshes = [];
            textSprites.forEach(m => disposeNode(m)); textSprites = [];
            document.getElementById('warning').style.display = 'none';

            if (point1.visible) drawDropLine(point1.position, 0xff4757, `Alb.A: ${(point1.position.y - groundLevel).toFixed(1)}m`);
            if (point2.visible) drawDropLine(point2.position, 0x1e90ff, `Alb.B: ${(point2.position.y - groundLevel).toFixed(1)}m`);

            if (!point1.visible || !point2.visible) {
                lineAB.visible = false;
                return;
            }
            
            const A = point1.position; const B = point2.position;
            const totalDist = A.distanceTo(B);
            const dir = new THREE.Vector3().subVectors(B, A).normalize();

            const type = document.getElementById('antType').value;
            
            if (type === 'none') {
                lineAB.geometry.setFromPoints([A, B]);
                lineAB.visible = true;
                drawRopeLabel(A, B);
                return;
            } else {
                lineAB.visible = false;
            }

            let wireLength = 0; const copperColor = 0xe67e22;

            if (type === 'dipole') {
                const band = parseFloat(document.getElementById('dipoleBand').value);
                wireLength = band / 2; const armLen = wireLength / 2;
                if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                const Center = new THREE.Vector3().copy(A).lerp(B, 0.5);
                const p1 = new THREE.Vector3().copy(Center).add(dir.clone().multiplyScalar(-armLen));
                const p2 = new THREE.Vector3().copy(Center).add(dir.clone().multiplyScalar(armLen));
                
                buildWire(p1, Center, copperColor); buildWire(Center, p2, copperColor);
                
                let balun = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                balun.position.copy(Center); scene.add(balun); markerMeshes.push(balun);
                
                drawDropLine(Center, 0x00ffff, `Feed: ${(Center.y - groundLevel).toFixed(1)}m`);
                drawRopeLabel(A, p1); drawRopeLabel(p2, B);

            } else if (type === 'endfed') {
                const startNode = document.getElementById('efStart').value === 'A' ? A : B;
                const activeDir = document.getElementById('efStart').value === 'A' ? dir.clone() : dir.clone().multiplyScalar(-1);
                const dist = parseFloat(document.getElementById('efDist').value);
                const L1 = parseFloat(document.getElementById('efL1').value);
                const L2 = parseFloat(document.getElementById('efL2').value);
                wireLength = dist + L1 + L2;
                if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                const pStartWire = new THREE.Vector3().copy(startNode).add(activeDir.clone().multiplyScalar(dist));
                const pFeed = new THREE.Vector3().copy(pStartWire).add(activeDir.clone().multiplyScalar(L1));
                const pEndWire = new THREE.Vector3().copy(pFeed).add(activeDir.clone().multiplyScalar(L2));
                
                buildWire(pStartWire, pFeed, copperColor); buildWire(pFeed, pEndWire, copperColor);
                
                let balun = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                balun.position.copy(pFeed); scene.add(balun); markerMeshes.push(balun);
                
                drawDropLine(pFeed, 0x2ed573, `Trafo: ${(pFeed.y - groundLevel).toFixed(1)}m`);
                
                if (document.getElementById('efStart').value === 'A') { drawRopeLabel(A, pStartWire); drawRopeLabel(pEndWire, B); }
                else { drawRopeLabel(B, pStartWire); drawRopeLabel(pEndWire, A); }

            } else if (type === 'longwire') {
                const startNode = document.getElementById('lwStart').value === 'A' ? A : B;
                const activeDir = document.getElementById('lwStart').value === 'A' ? dir.clone() : dir.clone().multiplyScalar(-1);
                const L = parseFloat(document.getElementById('lwLen').value);
                if (L > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
                const pEndWire = new THREE.Vector3().copy(startNode).add(activeDir.clone().multiplyScalar(L));
                
                buildWire(startNode, pEndWire, copperColor);
                
                let balun = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                balun.position.copy(startNode); scene.add(balun); markerMeshes.push(balun);
                
                if (document.getElementById('lwStart').value === 'A') { drawRopeLabel(pEndWire, B); }
                else { drawRopeLabel(pEndWire, A); }
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); }
        function animate() { renderer.setAnimationLoop( render ); }

        function render( timestamp, frame ) {
            if ( frame ) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                const apparentSizeFactor = 0.05; 
                if (point1.visible) point1.scale.setScalar(camera.position.distanceTo(point1.position) * apparentSizeFactor);
                if (point2.visible) point2.scale.setScalar(camera.position.distanceTo(point2.position) * apparentSizeFactor);
                markerMeshes.forEach(marker => marker.scale.setScalar(camera.position.distanceTo(marker.position) * apparentSizeFactor));
                
                textSprites.forEach(sprite => {
                    const dist = camera.position.distanceTo(sprite.position);
                    if (sprite.userData.isVertical) {
                        sprite.scale.set(dist * 0.06, dist * 0.25, 1);
                    } else {
                        sprite.scale.set(dist * 0.25, dist * 0.06, 1);
                    }
                });

                if ( hitTestSourceRequested === false ) {
                    session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                        session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) { hitTestSource = source; } );
                    } );
                    session.addEventListener( 'end', function () { hitTestSourceRequested = false; hitTestSource = null; } );
                    hitTestSourceRequested = true;
                }

                if (currentAction === 'PLACE_GROUND' || currentAction === 'PLACE_BASE_A' || currentAction === 'PLACE_BASE_B') {
                    reticle.visible = false;
                    if ( hitTestSource ) {
                        const hitTestResults = frame.getHitTestResults( hitTestSource );
                        if ( hitTestResults.length ) {
                            const pose = hitTestResults[0].getPose( referenceSpace );
                            reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                            reticle.quaternion.set(pose.transform.orientation.x, pose.transform.orientation.y, pose.transform.orientation.z, pose.transform.orientation.w);
                            reticle.visible = true;
                        }
                    }
                } else {
                    reticle.visible = false;
                }
            }
            renderer.render( scene, camera );
        }
    </script>
    
    <!-- Avvio del Service Worker -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Offline Engine Pronto!'))
                    .catch(err => console.log('Errore Service Worker:', err));
            });
        }
    </script>
</body>
</html>
