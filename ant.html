<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Ham Radio Planner - Precision Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; color: white; touch-action: none; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; z-index: 100; pointer-events: none; padding: 10px; box-sizing: border-box; }
        #top-bar { display: flex; justify-content: space-between; width: 100%; pointer-events: auto; gap: 5px; }
        
        #dataPanel { background: rgba(0,0,0,0.85); padding: 10px; border-radius: 8px; font-size: 11px; border-left: 4px solid #ffdd59; flex-grow: 1; }
        .data-value { font-weight: bold; color: #ffdd59; font-size: 13px; }
        
        #settingsPanel { background: rgba(20,20,20,0.9); padding: 10px; border-radius: 8px; pointer-events: auto; font-size: 11px; min-width: 100px; }
        input, select { width: 100%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px; margin-top: 2px; }

        .bottom-controls { display: flex; flex-direction: column; gap: 8px; width: 100%; align-items: center; }
        #instruction { background: #ffdd59; color: black; padding: 12px; border-radius: 8px; font-weight: bold; width: 100%; text-align: center; font-size: 14px; box-shadow: 0 4px 15px rgba(0,0,0,0.6); pointer-events: none; }
        
        .btn-row { display: flex; gap: 5px; width: 100%; pointer-events: auto; }
        .main-btn { flex: 1; padding: 14px 5px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; color: white; text-transform: uppercase; font-size: 11px; transition: 0.2s; }
        #btnGround { background: #2ed573; color: black; }
        #btnA { background: #ff4757; }
        #btnB { background: #1e90ff; }
        .active { outline: 3px solid white; transform: scale(1.05); opacity: 1 !important; z-index: 101; }

        #ground-opts { display: flex; background: rgba(30,30,30,0.95); padding: 15px; border-radius: 12px; width: 95%; pointer-events: auto; flex-direction: column; gap: 10px; margin-bottom: 10px; }
    </style>
</head>
<body>

    <div id="ui-container" style="display: none;">
        <div id="top-bar">
            <div id="dataPanel">
                Quota A: <span id="hA" class="data-value">--</span>m | B: <span id="hB" class="data-value">--</span>m<br>
                Centro: <span id="hC" class="data-value">--</span>m | Dist: <span id="distAB" class="data-value">--</span>m<br>
                Isolatori: A <span id="isoA" class="data-value">--</span>m, B <span id="isoB" class="data-value">--</span>m
            </div>
            <div id="settingsPanel">
                Banda: 
                <select id="bandSelect">
                    <option value="40">40m (20.2m)</option>
                    <option value="20">20m (10.1m)</option>
                    <option value="15">15m (6.8m)</option>
                    <option value="10">10m (5.1m)</option>
                </select>
                H Cell: <input type="number" id="inpHCell" value="1.50" step="0.01">
            </div>
        </div>

        <div class="bottom-controls">
            <div id="ground-opts">
                <div style="text-align:center; font-size:12px; margin-bottom:5px">CONFIGURAZIONE TERRENO</div>
                <button class="main-btn" id="btnHManual" style="background:#444">Usa Altezza Cellulare</button>
                <button class="main-btn" id="btn3Tocchi" style="background:#444">Calibra con 3 Tocchi</button>
            </div>

            <div id="instruction">Inizializzazione AR...</div>
            
            <div class="btn-row">
                <button id="btnGround" class="main-btn active">1. SUOLO</button>
                <button id="btnA" class="main-btn">2. PUNTO A</button>
                <button id="btnB" class="main-btn">3. PUNTO B</button>
            </div>
            <div class="btn-row">
                <button id="btnReset" class="main-btn" style="background:#333">Reset</button>
                <button id="btnPhoto" class="main-btn" style="background:#eee; color:#000">ðŸ“¸ FOTO</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let scene, camera, renderer, reticle, groundGrid, antennaWire;
        let hitTestSource = null, hitTestSourceRequested = false;
        let pA, pB;
        let groundLevel = 0;
        let currentAction = 'MENU_GROUND';
        let shot1Pos = new THREE.Vector3(), shot1Dir = new THREE.Vector3(), isShot1Done = false;
        let groundPoints = [];

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test', 'dom-overlay'],
                domOverlay: { root: document.getElementById('ui-container') }
            }));

            // Sfere Punti con materiale che non risente delle luci
            const pGeo = new THREE.SphereGeometry(1, 32, 32); // Raggio base 1, scalato in render()
            pA = new THREE.Mesh(pGeo, new THREE.MeshBasicMaterial({color: 0xff4757}));
            pB = new THREE.Mesh(pGeo, new THREE.MeshBasicMaterial({color: 0x1e90ff}));
            pA.visible = pB.visible = false;
            scene.add(pA, pB);

            // Mirino migliorato
            reticle = new THREE.Group();
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.04, 0.05, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial());
            const dot = new THREE.Mesh(new THREE.CircleGeometry(0.005, 16).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial());
            reticle.add(ring, dot);
            reticle.visible = false;
            scene.add(reticle);

            // Eventi UI
            document.getElementById('btnGround').onclick = () => { setAction('MENU_GROUND'); document.getElementById('ground-opts').style.display='flex'; };
            document.getElementById('btnHManual').onclick = () => { groundLevel = camera.position.y - parseFloat(document.getElementById('inpHCell').value); applyGround(); };
            document.getElementById('btn3Tocchi').onclick = () => { groundPoints = []; setAction('PLACE_GROUND_3'); document.getElementById('ground-opts').style.display='none'; };
            document.getElementById('btnA').onclick = () => setAction('TRI_A');
            document.getElementById('btnB').onclick = () => setAction('TRI_B');
            document.getElementById('btnReset').onclick = () => location.reload();
            document.getElementById('btnPhoto').onclick = takePhoto;

            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ui-container').style.display = 'flex';
                document.getElementById('ground-opts').style.display = 'flex';
                document.getElementById('instruction').innerText = "Calibra il suolo per iniziare";
            });

            renderer.setAnimationLoop(render);
        }

        function setAction(action) {
            currentAction = action;
            isShot1Done = false;
            document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));
            
            const inst = document.getElementById('instruction');
            if(action === 'MENU_GROUND') {
                document.getElementById('btnGround').classList.add('active');
                inst.innerText = "Configura il livello del terreno";
            } else if(action === 'TRI_A') {
                document.getElementById('btnA').classList.add('active');
                inst.innerText = "MIRA PUNTO A: 1Â° Tocco sul ramo";
            } else if(action === 'TRI_B') {
                document.getElementById('btnB').classList.add('active');
                inst.innerText = "MIRA PUNTO B: 1Â° Tocco sul ramo";
            } else if(action === 'PLACE_GROUND_3') {
                inst.innerText = `Tocca 3 punti sul suolo (${3 - groundPoints.length} rimanenti)`;
            }
        }

        function applyGround() {
            if(groundGrid) scene.remove(groundGrid);
            groundGrid = new THREE.GridHelper(20, 40, 0x2ed573, 0x444444);
            groundGrid.position.y = groundLevel;
            scene.add(groundGrid);
            document.getElementById('ground-opts').style.display='none';
            setAction('TRI_A'); // Passaggio automatico al punto A
        }

        function takePhoto() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL("image/png");
            const link = document.createElement('a');
            link.download = `ham-ar-plan.png`;
            link.href = dataURL;
            link.click();
        }

        function calculateTri(p1, d1, p2, d2) {
            const cross = new THREE.Vector3().crossVectors(d1, d2);
            const denom = cross.lengthSq();
            if (denom < 0.0001) return p1.clone().add(d1.clone().multiplyScalar(5));
            const detL = new THREE.Vector3().subVectors(p2, p1);
            const s = new THREE.Vector3().crossVectors(detL, d2).dot(cross) / denom;
            const t = new THREE.Vector3().crossVectors(detL, d1).dot(cross) / denom;
            const pResultA = p1.clone().add(d1.clone().multiplyScalar(s));
            const pResultB = p2.clone().add(d2.clone().multiplyScalar(t));
            return pResultA.lerp(pResultB, 0.5);
        }

        renderer.xr.getController(0).addEventListener('select', () => {
            if (currentAction === 'PLACE_GROUND_3' && reticle.visible) {
                groundPoints.push(reticle.position.y);
                if (groundPoints.length >= 3) {
                    groundLevel = groundPoints.reduce((a,b)=>a+b, 0) / 3;
                    applyGround();
                } else { setAction('PLACE_GROUND_3'); }
            } 
            else if (currentAction === 'TRI_A' || currentAction === 'TRI_B') {
                const cPos = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
                const cDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);

                if (!isShot1Done) {
                    shot1Pos.copy(cPos); shot1Dir.copy(cDir);
                    isShot1Done = true;
                    document.getElementById('instruction').innerText = "SPOSTATI di lato e mira lo stesso punto (2Â° Tocco)";
                } else {
                    const res = calculateTri(shot1Pos, shot1Dir, cPos, cDir);
                    if (currentAction === 'TRI_A') { 
                        pA.position.copy(res); pA.visible = true; 
                        setAction('TRI_B'); // Passaggio automatico al punto B
                    } else { 
                        pB.position.copy(res); pB.visible = true; 
                        setAction('NONE');
                        document.getElementById('instruction').innerText = "Misurazione Completata";
                    }
                    updateCalculations();
                }
            }
        });

        function updateCalculations() {
            if (!pA.visible || !pB.visible) return;
            const distTot = pA.position.distanceTo(pB.position);
            const band = parseFloat(document.getElementById('bandSelect').value);
            const realWireLen = (band == 40) ? 20.2 : (band == 20) ? 10.1 : (band == 15) ? 6.8 : 5.1;

            document.getElementById('hA').innerText = (pA.position.y - groundLevel).toFixed(1);
            document.getElementById('hB').innerText = (pB.position.y - groundLevel).toFixed(1);
            document.getElementById('hC').innerText = (((pA.position.y + pB.position.y)/2) - groundLevel).toFixed(1);
            document.getElementById('distAB').innerText = distTot.toFixed(2);
            
            const diff = (distTot - realWireLen) / 2;
            const iso = diff > 0 ? diff.toFixed(2) : "0.00";
            document.getElementById('isoA').innerText = iso;
            document.getElementById('isoB').innerText = iso;

            if(antennaWire) scene.remove(antennaWire);
            const geometry = new THREE.BufferGeometry().setFromPoints([pA.position, pB.position]);
            antennaWire = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xffdd59}));
            scene.add(antennaWire);
        }

        function render(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                const refSpace = renderer.xr.getReferenceSpace();

                // Scaling dei punti per mantenerli sempre visibili e della stessa dimensione a schermo
                [pA, pB].forEach(p => {
                    if (p.visible) {
                        const dist = camera.position.distanceTo(p.position);
                        const scale = dist * 0.015; // Fattore di scala costante rispetto alla vista
                        p.scale.set(scale, scale, scale);
                    }
                });

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(space => {
                        session.requestHitTestSource({ space }).then(src => hitTestSource = src);
                    });
                    hitTestSourceRequested = true;
                }

                if (currentAction === 'PLACE_GROUND_3' && hitTestSource) {
                    const hits = frame.getHitTestResults(hitTestSource);
                    if (hits.length) {
                        const pose = hits[0].getPose(refSpace);
                        reticle.visible = true;
                        reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                    }
                } else if (currentAction.includes('TRI')) {
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                    reticle.position.copy(camera.position).add(dir.multiplyScalar(2));
                    reticle.quaternion.copy(camera.quaternion);
                    reticle.visible = true;
                } else {
                    reticle.visible = false;
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
