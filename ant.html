<!DOCTYPE html>
<html lang="it">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
Â  Â  <title>AR Ham Radio Planner - UX Migliorata</title>
Â  Â  <style>
Â  Â  Â  Â  body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; touch-action: none; color: white;}
Â  Â  Â  Â Â 
Â  Â  Â  Â  #ui-container {
Â  Â  Â  Â  Â  Â  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  display: flex; flex-direction: column; justify-content: space-between;
Â  Â  Â  Â  Â  Â  z-index: 100; pointer-events: none; padding: 5px; box-sizing: border-box;
Â  Â  Â  Â  }

Â  Â  Â  Â  #top-bar { display: flex; justify-content: space-between; width: 100%; }

Â  Â  Â  Â  #dataPanel {
Â  Â  Â  Â  Â  Â  background: rgba(0, 0, 0, 0.85); padding: 10px; border-radius: 8px; font-size: 13px;
Â  Â  Â  Â  Â  Â  width: fit-content; max-width: 45%; pointer-events: auto; border-left: 3px solid #ffdd59;
Â  Â  Â  Â  }
Â  Â  Â  Â  .data-value { font-weight: bold; color: #ffdd59; font-size: 15px; }

Â  Â  Â  Â  #antennaPanel {
Â  Â  Â  Â  Â  Â  background: rgba(20, 40, 60, 0.95); padding: 10px; border-radius: 8px; font-size: 14px;
Â  Â  Â  Â  Â  Â  width: 48%; pointer-events: auto; border: 2px solid #1e90ff; display: none;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  /* Menu a tendina piÃ¹ grandi e facili da premere su cellulare */
Â  Â  Â  Â  #antennaPanel select, #antennaPanel input {Â 
Â  Â  Â  Â  Â  Â  width: 100%; margin-top: 5px; margin-bottom: 10px; padding: 8px;Â 
Â  Â  Â  Â  Â  Â  background: #222; color: white; border: 1px solid #777;Â 
Â  Â  Â  Â  Â  Â  border-radius: 5px; font-size: 14px; box-sizing: border-box;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .ant-settings { display: none; }
Â  Â  Â  Â  #warning { color: #ff4757; font-weight: bold; font-size: 12px; display: none; margin-top: 5px;}

Â  Â  Â  Â  .bottom-controls { display: flex; flex-direction: column; align-items: center; gap: 5px; width: 100%; }
Â  Â  Â  Â  .btn-row { display: flex; gap: 5px; pointer-events: auto; width: 100%; justify-content: center; }
Â  Â  Â  Â  .main-btn {
Â  Â  Â  Â  Â  Â  padding: 10px 5px; font-size: 13px; font-weight: bold; flex: 1; border-radius: 8px;
Â  Â  Â  Â  Â  Â  border: 2px solid transparent; cursor: pointer; color: white; opacity: 0.7; transition: 0.2s;
Â  Â  Â  Â  }
Â  Â  Â  Â  .main-btn.active { opacity: 1; border-color: white; transform: scale(1.02); }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #btnGround { background: #2ed573; color: black; }
Â  Â  Â  Â  #btnA { background: #ff4757; }
Â  Â  Â  Â  #btnB { background: #1e90ff; }
Â  Â  Â  Â  #btnPhoto { background: #ffffff; color: black; font-size: 14px; }
Â  Â  Â  Â  #btnReset { background: #ff9f43; color: black; font-size: 14px; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #instruction { text-align: center; color: #fff; font-weight: bold; background: #e1b12c; padding: 6px; border-radius: 5px; width: 100%; box-sizing: border-box; font-size: 13px;}
Â  Â  Â  Â Â 
Â  Â  Â  Â  .edit-panel { background: rgba(30,30,30,0.95); padding: 8px; border-radius: 8px; width: 100%; pointer-events: auto; box-sizing: border-box; text-align: center;}
Â  Â  Â  Â  .edit-row { display: flex; justify-content: center; gap: 10px; margin-top: 5px; }
Â  Â  Â  Â  .edit-btn { padding: 10px 15px; font-size: 14px; background: #444; color: white; border: 1px solid #777; border-radius: 5px; font-weight: bold; cursor: pointer;}
Â  Â  Â  Â  .edit-btn:active { background: #888; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .height-input-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; }
Â  Â  Â  Â  #phoneHeight { width: 60px; padding: 5px; font-size: 16px; text-align: center; font-weight: bold; border-radius: 4px; border: none;}
Â  Â  Â  Â Â 
Â  Â  Â  Â  #touchArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: -1; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #photoOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(46, 213, 115, 0.9); color: black; padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; display: none; z-index: 200; box-shadow: 0 4px 6px rgba(0,0,0,0.5);}
Â  Â  </style>
</head>
<body>

Â  Â  <div id="ui-container" style="display: none;">
Â  Â  Â  Â  <div id="touchArea"></div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div id="top-bar">
Â  Â  Â  Â  Â  Â  <div id="dataPanel">
Â  Â  Â  Â  Â  Â  Â  Â  <strong>QUOTE (dal suolo):</strong><br>
Â  Â  Â  Â  Â  Â  Â  Â  A: <span id="hA" class="data-value">--</span>m<br>
Â  Â  Â  Â  Â  Â  Â  Â  B: <span id="hB" class="data-value">--</span>m<br>
Â  Â  Â  Â  Â  Â  Â  Â  <hr style="border-color:#555; margin: 5px 0;">
Â  Â  Â  Â  Â  Â  Â  Â  Distanza A-B:<br><span id="distAB" class="data-value" style="font-size: 18px;">--</span>m
Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <div id="antennaPanel">
Â  Â  Â  Â  Â  Â  Â  Â  <strong>Configura Antenna</strong>
Â  Â  Â  Â  Â  Â  Â  Â  <select id="antType">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="dipole" selected>Dipolo</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="endfed">End Fed</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="longwire">Long Wire</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="none">Solo Filo</option>
Â  Â  Â  Â  Â  Â  Â  Â  </select>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="setDipole" class="ant-settings">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Banda:<br>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select id="dipoleBand">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="160">160m (~80m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="80">80m (~40m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="40">40m (~20m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="20">20m (~10m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="15">15m (~7m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="10">10m (~5m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="6">6m (~3m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="4">4m (~2m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <option value="2">2m (~1m filo)</option>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="setEndFed" class="ant-settings">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Start:<br>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select id="efStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Corda (m): <input type="number" id="efDist" value="1" step="0.5">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  L1 (m): <input type="number" id="efL1" value="10" step="0.5">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  L2 (m): <input type="number" id="efL2" value="2" step="0.5">
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="setLongWire" class="ant-settings">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Start:<br>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <select id="lwStart"><option value="A">Punto A</option><option value="B">Punto B</option></select>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Lunghezza (m): <input type="number" id="lwLen" value="20" step="1">
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  <div id="warning">âš ï¸ Antenna piÃ¹ lunga dello spazio!</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="bottom-controls">
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  <div id="panel-setup-ground" class="edit-panel" style="display: none;">
Â  Â  Â  Â  Â  Â  Â  Â  <div style="font-size: 13px; margin-bottom: 8px; color: #2ed573;">CALIBRAZIONE MATEMATICA</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="height-input-container">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Altezza cellulare: <input type="number" id="phoneHeight" value="1.40" step="0.05"> m
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="edit-row">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button class="edit-btn" id="btnSetByHeight" style="background:#2ed573; color:black;">Usa Altezza Cellulare</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button class="edit-btn" id="btnSetByTouch">Usa 3 Tocchi (Mirino)</button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <div id="panel-edit-point" class="edit-panel" style="display: none;">
Â  Â  Â  Â  Â  Â  Â  Â  <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">ğŸ‘† TRASCINA IL DITO per micro-correzioni.</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="edit-row">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button class="edit-btn" id="btnPFar">Lontano â†—ï¸</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button class="edit-btn" id="btnPNear">Vicino â†™ï¸</button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <div id="instruction">Inizializzazione...</div>

Â  Â  Â  Â  Â  Â  <div class="btn-row">
Â  Â  Â  Â  Â  Â  Â  Â  <button id="btnGround" class="main-btn">1. Terreno</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button id="btnA" class="main-btn">2. Albero A</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button id="btnB" class="main-btn">3. Albero B</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  <div class="btn-row">
Â  Â  Â  Â  Â  Â  Â  Â  <button id="btnReset" class="main-btn">ğŸ”„ Reset Totale</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button id="btnPhoto" class="main-btn">ğŸ“¸ Fai Foto</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div id="photoOverlay">Usa i tasti screenshot! (Torno tra 5s)</div>

Â  Â  <script type="importmap">
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "imports": {
Â  Â  Â  Â  Â  Â  Â  Â  "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
Â  Â  Â  Â  Â  Â  Â  Â  "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  </script>

Â  Â  <script type="module">
Â  Â  Â  Â  import * as THREE from 'three';
Â  Â  Â  Â  import { ARButton } from 'three/addons/webxr/ARButton.js';

Â  Â  Â  Â  let container, camera, scene, renderer, controller, reticle;
Â  Â  Â  Â  let hitTestSource = null, hitTestSourceRequested = false;

Â  Â  Â  Â  let point1, point2, groundGrid, lineAB;
Â  Â  Â  Â  let antennaMeshes = [];Â 
Â  Â  Â  Â  let markerMeshes = [];Â 
Â  Â  Â  Â  let textSprites = [];Â 
Â  Â  Â  Â  let laserMesh = null;
Â  Â  Â  Â Â 
Â  Â  Â  Â  let groundLevel = 0;Â 
Â  Â  Â  Â  let isGroundSet = false;
Â  Â  Â  Â  let groundCalibrationPoints = [];Â 
Â  Â  Â  Â  let tempGroundMarkers = [];
Â  Â  Â  Â Â 
Â  Â  Â  Â  let currentAction = 'NONE';Â 

Â  Â  Â  Â  let shot1Pos = new THREE.Vector3();
Â  Â  Â  Â  let shot1Dir = new THREE.Vector3();
Â  Â  Â  Â  let isShot1Done = false;

Â  Â  Â  Â  let lastTouchX = 0, lastTouchY = 0;
Â  Â  Â  Â  let isDragging = false, hasDragged = false;Â 

Â  Â  Â  Â  init();
Â  Â  Â  Â  animate();

Â  Â  Â  Â  function init() {
Â  Â  Â  Â  Â  Â  container = document.createElement( 'div' );
Â  Â  Â  Â  Â  Â  document.body.appendChild( container );
Â  Â  Â  Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  Â  Â  Â  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 200 );

Â  Â  Â  Â  Â  Â  const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );
Â  Â  Â  Â  Â  Â  light.position.set( 0.5, 1, 0.25 ); scene.add( light );

Â  Â  Â  Â  Â  Â  renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
Â  Â  Â  Â  Â  Â  renderer.setPixelRatio( window.devicePixelRatio );
Â  Â  Â  Â  Â  Â  renderer.setSize( window.innerWidth, window.innerHeight );
Â  Â  Â  Â  Â  Â  renderer.xr.enabled = true;
Â  Â  Â  Â  Â  Â  container.appendChild( renderer.domElement );

Â  Â  Â  Â  Â  Â  document.body.appendChild( ARButton.createButton( renderer, {Â 
Â  Â  Â  Â  Â  Â  Â  Â  requiredFeatures: [ 'hit-test', 'dom-overlay' ],
Â  Â  Â  Â  Â  Â  Â  Â  domOverlay: { root: document.getElementById('ui-container') }
Â  Â  Â  Â  Â  Â  } ) );

Â  Â  Â  Â  Â  Â  groundGrid = new THREE.GridHelper( 3, 30, 0x2ed573, 0x2ed573 );
Â  Â  Â  Â  Â  Â  groundGrid.material.opacity = 0.8; groundGrid.material.transparent = true; groundGrid.visible = false;
Â  Â  Â  Â  Â  Â  scene.add( groundGrid );

Â  Â  Â  Â  Â  Â  const pointGeo = new THREE.SphereGeometry( 0.05, 32, 32 );
Â  Â  Â  Â  Â  Â  point1 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0xff4757 } ) ); point1.visible = false; scene.add( point1 );
Â  Â  Â  Â  Â  Â  point2 = new THREE.Mesh( pointGeo, new THREE.MeshPhongMaterial( { color: 0x1e90ff } ) ); point2.visible = false; scene.add( point2 );

Â  Â  Â  Â  Â  Â  lineAB = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: 0xffdd59, linewidth: 1 }));
Â  Â  Â  Â  Â  Â  lineAB.visible = false; scene.add(lineAB);

Â  Â  Â  Â  Â  Â  reticle = new THREE.Mesh( new THREE.RingGeometry( 0.02, 0.04, 32 ).rotateX( - Math.PI / 2 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
Â  Â  Â  Â  Â  Â  reticle.matrixAutoUpdate = true; reticle.visible = false; scene.add( reticle );

Â  Â  Â  Â  Â  Â  controller = renderer.xr.getController( 0 );
Â  Â  Â  Â  Â  Â  controller.addEventListener( 'select', onSelect );
Â  Â  Â  Â  Â  Â  scene.add( controller );

Â  Â  Â  Â  Â  Â  window.addEventListener( 'resize', onWindowResize );

Â  Â  Â  Â  Â  Â  renderer.xr.addEventListener('sessionstart', () => {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('ui-container').style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  updateAntennaUI(); // Inizializza i menu a tendina
Â  Â  Â  Â  Â  Â  Â  Â  setAction('MENU_GROUND');
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  document.getElementById('ui-container').addEventListener('beforexrselect', (ev) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (ev.target.id !== 'touchArea') ev.preventDefault();
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  document.getElementById('btnGround').addEventListener('click', () => setAction('MENU_GROUND'));
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  document.getElementById('btnSetByHeight').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  const height = parseFloat(document.getElementById('phoneHeight').value);
Â  Â  Â  Â  Â  Â  Â  Â  if(isNaN(height) || height <= 0) return;
Â  Â  Â  Â  Â  Â  Â  Â  groundLevel = camera.position.y - height;
Â  Â  Â  Â  Â  Â  Â  Â  groundGrid.position.set(camera.position.x, groundLevel, camera.position.z);
Â  Â  Â  Â  Â  Â  Â  Â  groundGrid.visible = true; isGroundSet = true;
Â  Â  Â  Â  Â  Â  Â  Â  setAction('NONE'); updateCalculations();
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  document.getElementById('btnSetByTouch').addEventListener('click', () => setAction('PLACE_GROUND'));
Â  Â  Â  Â  Â  Â  document.getElementById('btnA').addEventListener('click', () => { isShot1Done = false; setAction('TRIANGULATE_A'); });
Â  Â  Â  Â  Â  Â  document.getElementById('btnB').addEventListener('click', () => { isShot1Done = false; setAction('TRIANGULATE_B'); });
Â  Â  Â  Â  Â  Â  document.getElementById('btnPFar').addEventListener('click', () => adjustDepth(0.5));
Â  Â  Â  Â  Â  Â  document.getElementById('btnPNear').addEventListener('click', () => adjustDepth(-0.5));
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Eventi per aggiornare la grafica dell'antenna al volo
Â  Â  Â  Â  Â  Â  document.getElementById('antType').addEventListener('change', updateAntennaUI);
Â  Â  Â  Â  Â  Â  document.querySelectorAll('#antennaPanel select, #antennaPanel input').forEach(el => {
Â  Â  Â  Â  Â  Â  Â  Â  el.addEventListener('change', drawAntenna);
Â  Â  Â  Â  Â  Â  Â  Â  el.addEventListener('input', drawAntenna);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  document.getElementById('btnPhoto').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'hidden');
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('antennaPanel').style.visibility = 'hidden';
Â  Â  Â  Â  Â  Â  Â  Â  const toast = document.getElementById('photoOverlay');
Â  Â  Â  Â  Â  Â  Â  Â  toast.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  toast.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.querySelectorAll('.btn-row').forEach(row => row.style.visibility = 'visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (point1.visible && point2.visible) document.getElementById('antennaPanel').style.visibility = 'visible';
Â  Â  Â  Â  Â  Â  Â  Â  }, 5000);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  document.getElementById('btnReset').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  point1.visible = false;
Â  Â  Â  Â  Â  Â  Â  Â  point2.visible = false;
Â  Â  Â  Â  Â  Â  Â  Â  groundGrid.visible = false;
Â  Â  Â  Â  Â  Â  Â  Â  lineAB.visible = false;

Â  Â  Â  Â  Â  Â  Â  Â  antennaMeshes.forEach(m => scene.remove(m)); antennaMeshes = [];
Â  Â  Â  Â  Â  Â  Â  Â  markerMeshes.forEach(m => scene.remove(m)); markerMeshes = [];
Â  Â  Â  Â  Â  Â  Â  Â  textSprites.forEach(m => scene.remove(m)); textSprites = [];
Â  Â  Â  Â  Â  Â  Â  Â  clearTempMarkers();
Â  Â  Â  Â  Â  Â  Â  Â  if (laserMesh) { scene.remove(laserMesh); laserMesh = null; }

Â  Â  Â  Â  Â  Â  Â  Â  isGroundSet = false;
Â  Â  Â  Â  Â  Â  Â  Â  groundLevel = 0;
Â  Â  Â  Â  Â  Â  Â  Â  isShot1Done = false;

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('hA').innerText = '--';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('hB').innerText = '--';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('distAB').innerText = '--';
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Ripristina il valore base del menu e aggiorna
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('antType').value = 'dipole';
Â  Â  Â  Â  Â  Â  Â  Â  updateAntennaUI();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('antennaPanel').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('warning').style.display = 'none';

Â  Â  Â  Â  Â  Â  Â  Â  setAction('MENU_GROUND');
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  const touchArea = document.getElementById('touchArea');
Â  Â  Â  Â  Â  Â  touchArea.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (e.touches.length === 1 && (currentAction === 'EDIT_A' || currentAction === 'EDIT_B')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isDragging = true; hasDragged = false;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  touchArea.addEventListener('touchmove', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (!isDragging) return;
Â  Â  Â  Â  Â  Â  Â  Â  hasDragged = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (e.touches.length === 1 && (currentAction === 'EDIT_A' || currentAction === 'EDIT_B')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let pt = currentAction === 'EDIT_A' ? point1 : point2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!pt || !pt.visible) return;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let touchX = e.touches[0].clientX; let touchY = e.touches[0].clientY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let deltaX = touchX - lastTouchX; let deltaY = touchY - lastTouchY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let dist = camera.position.distanceTo(pt.position);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let sensitivity = 0.001 * dist;Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pt.position.add(camRight.multiplyScalar(deltaX * sensitivity));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pt.position.add(camUp.multiplyScalar(-deltaY * sensitivity));Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastTouchX = touchX; lastTouchY = touchY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateCalculations();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  touchArea.addEventListener('touchend', () => { isDragging = false; });
Â  Â  Â  Â  }

Â  Â  Â  Â  function setAction(action) {
Â  Â  Â  Â  Â  Â  currentAction = action;
Â  Â  Â  Â  Â  Â  document.getElementById('panel-setup-ground').style.display = 'none';
Â  Â  Â  Â  Â  Â  document.getElementById('panel-edit-point').style.display = 'none';
Â  Â  Â  Â  Â  Â  document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));

Â  Â  Â  Â  Â  Â  let inst = document.getElementById('instruction');
Â  Â  Â  Â  Â  Â  if (laserMesh) { scene.remove(laserMesh); laserMesh = null; }

Â  Â  Â  Â  Â  Â  if (action === 'MENU_GROUND') {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('btnGround').classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('panel-setup-ground').style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  inst.innerText = "Scegli come impostare la quota zero del suolo."; inst.style.background = "#2ed573";
Â  Â  Â  Â  Â  Â  } else if (action === 'PLACE_GROUND') {
Â  Â  Â  Â  Â  Â  Â  Â  groundCalibrationPoints = []; clearTempMarkers();
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('btnGround').classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  inst.innerText = "Tocca 3 punti a terra per calibrare lo Zero."; inst.style.background = "#2ed573";
Â  Â  Â  Â  Â  Â  } else if (action === 'TRIANGULATE_A' || action === 'TRIANGULATE_B') {
Â  Â  Â  Â  Â  Â  Â  Â  const btn = action === 'TRIANGULATE_A' ? 'btnA' : 'btnB';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById(btn).classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  inst.innerText = "1. MIRA al ramo esatto e TOCCA."; inst.style.background = action === 'TRIANGULATE_A' ? "#ff4757" : "#1e90ff";
Â  Â  Â  Â  Â  Â  } else if (action === 'EDIT_A' || action === 'EDIT_B') {
Â  Â  Â  Â  Â  Â  Â  Â  const btn = action === 'EDIT_A' ? 'btnA' : 'btnB';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById(btn).classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('panel-edit-point').style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  inst.innerText = "Trascina il punto per correzioni fini."; inst.style.background = action === 'EDIT_A' ? "#ff4757" : "#1e90ff";
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  inst.innerText = "Antenna pronta. Usa il tasto Foto per salvare."; inst.style.background = "#555";
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function calculateTriangulation(p1, d1, p2, d2) {
Â  Â  Â  Â  Â  Â  const w0 = new THREE.Vector3().subVectors(p1, p2);
Â  Â  Â  Â  Â  Â  const a = d1.dot(d1); const b = d1.dot(d2); const c = d2.dot(d2);
Â  Â  Â  Â  Â  Â  const d = d1.dot(w0); const e = d2.dot(w0);
Â  Â  Â  Â  Â  Â  const denom = a * c - b * b;
Â  Â  Â  Â  Â  Â  if (denom < 0.001) return new THREE.Vector3().copy(p1).add(d1.clone().multiplyScalar(15));Â 
Â  Â  Â  Â  Â  Â  const s = (b * e - c * d) / denom;
Â  Â  Â  Â  Â  Â  const t = (a * e - b * d) / denom;
Â  Â  Â  Â  Â  Â  const pointOnRay1 = new THREE.Vector3().copy(p1).add(d1.clone().multiplyScalar(s));
Â  Â  Â  Â  Â  Â  const pointOnRay2 = new THREE.Vector3().copy(p2).add(d2.clone().multiplyScalar(t));
Â  Â  Â  Â  Â  Â  return new THREE.Vector3().addVectors(pointOnRay1, pointOnRay2).multiplyScalar(0.5);
Â  Â  Â  Â  }

Â  Â  Â  Â  function createLaserRay(origin, direction, color) {
Â  Â  Â  Â  Â  Â  const end = origin.clone().add(direction.clone().multiplyScalar(50));
Â  Â  Â  Â  Â  Â  const geo = new THREE.BufferGeometry().setFromPoints([origin, end]);
Â  Â  Â  Â  Â  Â  const mat = new THREE.LineBasicMaterial({ color: color, linewidth: 2, transparent: true, opacity: 0.5 });
Â  Â  Â  Â  Â  Â  const mesh = new THREE.Line(geo, mat); scene.add(mesh); return mesh;
Â  Â  Â  Â  }

Â  Â  Â  Â  function makeTextSprite(message, textColor = '#ffffff', bgColor = 'rgba(0, 0, 0, 0.7)') {
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = 512; canvas.height = 128;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = bgColor;
Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  Â  Â  ctx.font = 'bold 42px sans-serif';
Â  Â  Â  Â  Â  Â  ctx.fillStyle = textColor;
Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
Â  Â  Â  Â  Â  Â  ctx.fillText(message, 256, 64);
Â  Â  Â  Â  Â  Â  const texture = new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  Â  Â  const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
Â  Â  Â  Â  Â  Â  return new THREE.Sprite(spriteMat);
Â  Â  Â  Â  }

Â  Â  Â  Â  function drawDropLine(position, color, labelText) {
Â  Â  Â  Â  Â  Â  if (!isGroundSet) return;
Â  Â  Â  Â  Â  Â  const groundPos = new THREE.Vector3(position.x, groundLevel, position.z);
Â  Â  Â  Â  Â  Â  const geo = new THREE.BufferGeometry().setFromPoints([position, groundPos]);
Â  Â  Â  Â  Â  Â  const mat = new THREE.LineDashedMaterial({ color: color, dashSize: 0.2, gapSize: 0.2 });
Â  Â  Â  Â  Â  Â  const line = new THREE.Line(geo, mat);
Â  Â  Â  Â  Â  Â  line.computeLineDistances();
Â  Â  Â  Â  Â  Â  scene.add(line); antennaMeshes.push(line);

Â  Â  Â  Â  Â  Â  const labelY = groundLevel + (position.y - groundLevel) * 0.3;
Â  Â  Â  Â  Â  Â  const sprite = makeTextSprite(labelText, `#${color.toString(16).padStart(6, '0')}`);
Â  Â  Â  Â  Â  Â  sprite.position.set(position.x, labelY, position.z);
Â  Â  Â  Â  Â  Â  scene.add(sprite); textSprites.push(sprite);
Â  Â  Â  Â  }

Â  Â  Â  Â  function drawRopeLabel(pStart, pEnd) {
Â  Â  Â  Â  Â  Â  const dist = pStart.distanceTo(pEnd);
Â  Â  Â  Â  Â  Â  if (dist < 0.1) return;
Â  Â  Â  Â  Â  Â  const midPoint = new THREE.Vector3().copy(pStart).lerp(pEnd, 0.5);
Â  Â  Â  Â  Â  Â  const sprite = makeTextSprite(`Corda: ${dist.toFixed(1)}m`, '#ffdd59', 'rgba(50, 50, 0, 0.8)');
Â  Â  Â  Â  Â  Â  sprite.position.copy(midPoint);
Â  Â  Â  Â  Â  Â  scene.add(sprite); textSprites.push(sprite);
Â  Â  Â  Â  }

Â  Â  Â  Â  function onSelect() {
Â  Â  Â  Â  Â  Â  if (hasDragged) { hasDragged = false; return; }

Â  Â  Â  Â  Â  Â  if (currentAction === 'PLACE_GROUND') {
Â  Â  Â  Â  Â  Â  Â  Â  if(!reticle.visible) return;
Â  Â  Â  Â  Â  Â  Â  Â  groundCalibrationPoints.push(reticle.position.y);
Â  Â  Â  Â  Â  Â  Â  Â  let marker = new THREE.Mesh( new THREE.SphereGeometry(0.02), new THREE.MeshBasicMaterial({color: 0xffff00}) );
Â  Â  Â  Â  Â  Â  Â  Â  marker.position.copy(reticle.position); scene.add(marker); tempGroundMarkers.push(marker);
Â  Â  Â  Â  Â  Â  Â  Â  if (groundCalibrationPoints.length === 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groundLevel = groundCalibrationPoints.reduce((a, b) => a + b, 0) / 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groundGrid.position.set(reticle.position.x, groundLevel, reticle.position.z);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groundGrid.visible = true; isGroundSet = true; clearTempMarkers(); setAction('NONE'); updateCalculations();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (currentAction === 'TRIANGULATE_A' || currentAction === 'TRIANGULATE_B') {
Â  Â  Â  Â  Â  Â  Â  Â  const camPos = new THREE.Vector3(); camera.getWorldPosition(camPos);
Â  Â  Â  Â  Â  Â  Â  Â  const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);

Â  Â  Â  Â  Â  Â  Â  Â  if (!isShot1Done) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  shot1Pos.copy(camPos); shot1Dir.copy(camDir); isShot1Done = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let color = currentAction === 'TRIANGULATE_A' ? 0xff4757 : 0x1e90ff;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  laserMesh = createLaserRay(shot1Pos, shot1Dir, color);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('instruction').innerText = "2. Spostati di lato, mira DI NUOVO al ramo e tocca.";
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const finalPoint = calculateTriangulation(shot1Pos, shot1Dir, camPos, camDir);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentAction === 'TRIANGULATE_A') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  point1.position.copy(finalPoint); point1.visible = true; setAction('EDIT_A');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  point2.position.copy(finalPoint); point2.visible = true; setAction('EDIT_B');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (laserMesh) { scene.remove(laserMesh); laserMesh = null; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateCalculations();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function clearTempMarkers() { tempGroundMarkers.forEach(m => scene.remove(m)); tempGroundMarkers = []; }

Â  Â  Â  Â  function adjustDepth(amount) {
Â  Â  Â  Â  Â  Â  let pt = currentAction === 'EDIT_A' ? point1 : (currentAction === 'EDIT_B' ? point2 : null);
Â  Â  Â  Â  Â  Â  if (!pt || !pt.visible) return;
Â  Â  Â  Â  Â  Â  const toPoint = new THREE.Vector3().subVectors(pt.position, camera.position);
Â  Â  Â  Â  Â  Â  toPoint.y = 0; toPoint.normalize();
Â  Â  Â  Â  Â  Â  pt.position.add(toPoint.clone().multiplyScalar(amount));
Â  Â  Â  Â  Â  Â  updateCalculations();
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateCalculations() {
Â  Â  Â  Â  Â  Â  if (isGroundSet && point1.visible) document.getElementById('hA').innerText = (point1.position.y - groundLevel).toFixed(1);
Â  Â  Â  Â  Â  Â  if (isGroundSet && point2.visible) document.getElementById('hB').innerText = (point2.position.y - groundLevel).toFixed(1);
Â  Â  Â  Â  Â  Â  if (point1.visible && point2.visible) {
Â  Â  Â  Â  Â  Â  Â  Â  lineAB.geometry.setFromPoints([point1.position, point2.position]);
Â  Â  Â  Â  Â  Â  Â  Â  lineAB.visible = true;
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('distAB').innerText = point1.position.distanceTo(point2.position).toFixed(1);
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('antennaPanel').style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  drawAntenna();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateAntennaUI() {
Â  Â  Â  Â  Â  Â  const type = document.getElementById('antType').value;
Â  Â  Â  Â  Â  Â  document.querySelectorAll('.ant-settings').forEach(el => el.style.display = 'none');
Â  Â  Â  Â  Â  Â  if (type === 'dipole') document.getElementById('setDipole').style.display = 'block';
Â  Â  Â  Â  Â  Â  if (type === 'endfed') document.getElementById('setEndFed').style.display = 'block';
Â  Â  Â  Â  Â  Â  if (type === 'longwire') document.getElementById('setLongWire').style.display = 'block';
Â  Â  Â  Â  Â  Â  drawAntenna(); // Ridisegna se c'Ã¨ giÃ  un'antenna in scena
Â  Â  Â  Â  }

Â  Â  Â  Â  function buildWire(pStart, pEnd, color, thickness=0.015) {
Â  Â  Â  Â  Â  Â  const dist = pStart.distanceTo(pEnd);
Â  Â  Â  Â  Â  Â  const cylinder = new THREE.Mesh( new THREE.CylinderGeometry(thickness, thickness, dist, 8), new THREE.MeshBasicMaterial({color: color}) );
Â  Â  Â  Â  Â  Â  cylinder.position.copy(pStart).lerp(pEnd, 0.5);
Â  Â  Â  Â  Â  Â  cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(pEnd, pStart).normalize());
Â  Â  Â  Â  Â  Â  scene.add(cylinder); antennaMeshes.push(cylinder);
Â  Â  Â  Â  }

Â  Â  Â  Â  function drawAntenna() {
Â  Â  Â  Â  Â  Â  antennaMeshes.forEach(m => scene.remove(m)); antennaMeshes = [];
Â  Â  Â  Â  Â  Â  markerMeshes.forEach(m => scene.remove(m)); markerMeshes = [];
Â  Â  Â  Â  Â  Â  textSprites.forEach(m => scene.remove(m)); textSprites = [];
Â  Â  Â  Â  Â  Â  document.getElementById('warning').style.display = 'none';

Â  Â  Â  Â  Â  Â  if (!point1.visible || !point2.visible) return;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const A = point1.position; const B = point2.position;
Â  Â  Â  Â  Â  Â  const totalDist = A.distanceTo(B);
Â  Â  Â  Â  Â  Â  const dir = new THREE.Vector3().subVectors(B, A).normalize();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  drawDropLine(A, 0xff4757, `Alb.A: ${(A.y - groundLevel).toFixed(1)}m`);
Â  Â  Â  Â  Â  Â  drawDropLine(B, 0x1e90ff, `Alb.B: ${(B.y - groundLevel).toFixed(1)}m`);

Â  Â  Â  Â  Â  Â  const type = document.getElementById('antType').value;
Â  Â  Â  Â  Â  Â  if (type === 'none') {
Â  Â  Â  Â  Â  Â  Â  Â  drawRopeLabel(A, B);
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  let wireLength = 0; const copperColor = 0xe67e22;

Â  Â  Â  Â  Â  Â  if (type === 'dipole') {
Â  Â  Â  Â  Â  Â  Â  Â  const band = parseFloat(document.getElementById('dipoleBand').value);
Â  Â  Â  Â  Â  Â  Â  Â  wireLength = band / 2; const armLen = wireLength / 2;
Â  Â  Â  Â  Â  Â  Â  Â  if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
Â  Â  Â  Â  Â  Â  Â  Â  const Center = new THREE.Vector3().copy(A).lerp(B, 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  const p1 = new THREE.Vector3().copy(Center).add(dir.clone().multiplyScalar(-armLen));
Â  Â  Â  Â  Â  Â  Â  Â  const p2 = new THREE.Vector3().copy(Center).add(dir.clone().multiplyScalar(armLen));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  buildWire(p1, Center, copperColor); buildWire(Center, p2, copperColor);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let balun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), new THREE.MeshBasicMaterial({color: 0x00ffff}));
Â  Â  Â  Â  Â  Â  Â  Â  balun.position.copy(Center); scene.add(balun); markerMeshes.push(balun);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  drawDropLine(Center, 0x00ffff, `Feed: ${(Center.y - groundLevel).toFixed(1)}m`);
Â  Â  Â  Â  Â  Â  Â  Â  drawRopeLabel(A, p1); drawRopeLabel(p2, B);

Â  Â  Â  Â  Â  Â  } else if (type === 'endfed') {
Â  Â  Â  Â  Â  Â  Â  Â  const startNode = document.getElementById('efStart').value === 'A' ? A : B;
Â  Â  Â  Â  Â  Â  Â  Â  const activeDir = document.getElementById('efStart').value === 'A' ? dir.clone() : dir.clone().multiplyScalar(-1);
Â  Â  Â  Â  Â  Â  Â  Â  const dist = parseFloat(document.getElementById('efDist').value);
Â  Â  Â  Â  Â  Â  Â  Â  const L1 = parseFloat(document.getElementById('efL1').value);
Â  Â  Â  Â  Â  Â  Â  Â  const L2 = parseFloat(document.getElementById('efL2').value);
Â  Â  Â  Â  Â  Â  Â  Â  wireLength = dist + L1 + L2;
Â  Â  Â  Â  Â  Â  Â  Â  if (wireLength > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
Â  Â  Â  Â  Â  Â  Â  Â  const pStartWire = new THREE.Vector3().copy(startNode).add(activeDir.clone().multiplyScalar(dist));
Â  Â  Â  Â  Â  Â  Â  Â  const pFeed = new THREE.Vector3().copy(pStartWire).add(activeDir.clone().multiplyScalar(L1));
Â  Â  Â  Â  Â  Â  Â  Â  const pEndWire = new THREE.Vector3().copy(pFeed).add(activeDir.clone().multiplyScalar(L2));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  buildWire(pStartWire, pFeed, copperColor); buildWire(pFeed, pEndWire, copperColor);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let balun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), new THREE.MeshBasicMaterial({color: 0x2ed573}));
Â  Â  Â  Â  Â  Â  Â  Â  balun.position.copy(pFeed); scene.add(balun); markerMeshes.push(balun);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  drawDropLine(pFeed, 0x2ed573, `Feed: ${(pFeed.y - groundLevel).toFixed(1)}m`);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (document.getElementById('efStart').value === 'A') { drawRopeLabel(A, pStartWire); drawRopeLabel(pEndWire, B); }
Â  Â  Â  Â  Â  Â  Â  Â  else { drawRopeLabel(B, pStartWire); drawRopeLabel(pEndWire, A); }

Â  Â  Â  Â  Â  Â  } else if (type === 'longwire') {
Â  Â  Â  Â  Â  Â  Â  Â  const startNode = document.getElementById('lwStart').value === 'A' ? A : B;
Â  Â  Â  Â  Â  Â  Â  Â  const activeDir = document.getElementById('lwStart').value === 'A' ? dir.clone() : dir.clone().multiplyScalar(-1);
Â  Â  Â  Â  Â  Â  Â  Â  const L = parseFloat(document.getElementById('lwLen').value);
Â  Â  Â  Â  Â  Â  Â  Â  if (L > totalDist) { document.getElementById('warning').style.display = 'block'; return; }
Â  Â  Â  Â  Â  Â  Â  Â  const pEndWire = new THREE.Vector3().copy(startNode).add(activeDir.clone().multiplyScalar(L));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  buildWire(startNode, pEndWire, copperColor);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let balun = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), new THREE.MeshBasicMaterial({color: 0xffdd59}));
Â  Â  Â  Â  Â  Â  Â  Â  balun.position.copy(startNode); scene.add(balun); markerMeshes.push(balun);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  drawDropLine(startNode, 0xffdd59, `Feed: ${(startNode.y - groundLevel).toFixed(1)}m`);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (document.getElementById('lwStart').value === 'A') { drawRopeLabel(pEndWire, B); }
Â  Â  Â  Â  Â  Â  Â  Â  else { drawRopeLabel(pEndWire, A); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); }
Â  Â  Â  Â  function animate() { renderer.setAnimationLoop( render ); }

Â  Â  Â  Â  function render( timestamp, frame ) {
Â  Â  Â  Â  Â  Â  if ( frame ) {
Â  Â  Â  Â  Â  Â  Â  Â  const referenceSpace = renderer.xr.getReferenceSpace();
Â  Â  Â  Â  Â  Â  Â  Â  const session = renderer.xr.getSession();

Â  Â  Â  Â  Â  Â  Â  Â  const apparentSizeFactor = 0.05;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (point1.visible) point1.scale.setScalar(camera.position.distanceTo(point1.position) * apparentSizeFactor);
Â  Â  Â  Â  Â  Â  Â  Â  if (point2.visible) point2.scale.setScalar(camera.position.distanceTo(point2.position) * apparentSizeFactor);
Â  Â  Â  Â  Â  Â  Â  Â  markerMeshes.forEach(marker => marker.scale.setScalar(camera.position.distanceTo(marker.position) * apparentSizeFactor));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  textSprites.forEach(sprite => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dist = camera.position.distanceTo(sprite.position);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sprite.scale.set(dist * 0.25, dist * 0.06, 1);
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  if ( hitTestSourceRequested === false ) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) { hitTestSource = source; } );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  session.addEventListener( 'end', function () { hitTestSourceRequested = false; hitTestSource = null; } );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  hitTestSourceRequested = true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (currentAction === 'PLACE_GROUND') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.visible = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ( hitTestSource ) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const hitTestResults = frame.getHitTestResults( hitTestSource );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ( hitTestResults.length ) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pose = hitTestResults[0].getPose( referenceSpace );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.quaternion.set(pose.transform.orientation.x, pose.transform.orientation.y, pose.transform.orientation.z, pose.transform.orientation.w);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.visible = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else if (currentAction === 'TRIANGULATE_A' || currentAction === 'TRIANGULATE_B') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = 2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.position.copy(camera.position).add(camDir.multiplyScalar(distance));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.quaternion.copy(camera.quaternion);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.visible = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reticle.visible = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  renderer.render( scene, camera );
Â  Â  Â  Â  }
Â  Â  </script>
</body>
</html>
