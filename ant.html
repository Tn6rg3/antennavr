<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Ham Radio Planner Pro</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; touch-action: none; color: white;}
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 100; pointer-events: none; padding: 10px; box-sizing: border-box;
        }
        #top-bar { display: flex; justify-content: space-between; width: 100%; align-items: flex-start; }
        #dataPanel {
            background: rgba(0, 0, 0, 0.8); padding: 12px; border-radius: 8px; font-size: 13px;
            width: fit-content; pointer-events: auto; border-left: 4px solid #ffdd59;
        }
        .data-value { font-weight: bold; color: #ffdd59; font-size: 16px; }
        #antennaPanel {
            background: rgba(20, 40, 60, 0.9); padding: 12px; border-radius: 8px; font-size: 14px;
            width: 45%; pointer-events: auto; border: 2px solid #1e90ff; display: none;
        }
        #antennaPanel select, #antennaPanel input { 
            width: 100%; margin-top: 5px; margin-bottom: 8px; padding: 8px; 
            background: #222; color: white; border: 1px solid #777; border-radius: 5px;
        }
        .ant-settings { display: none; }
        #warning { color: #ff4757; font-weight: bold; font-size: 12px; display: none; }

        .bottom-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; }
        .btn-row { display: flex; gap: 8px; pointer-events: auto; width: 100%; }
        .main-btn {
            padding: 12px 5px; font-size: 13px; font-weight: bold; flex: 1; border-radius: 8px;
            border: none; cursor: pointer; color: white; opacity: 0.8; transition: 0.2s;
        }
        .main-btn.active { opacity: 1; box-shadow: 0 0 15px white; transform: scale(1.05); }
        #btnGround { background: #2ed573; color: black; }
        #btnA { background: #ff4757; }
        #btnB { background: #1e90ff; }
        
        #instruction { text-align: center; color: #000; font-weight: bold; background: #ffdd59; padding: 10px; border-radius: 8px; width: 100%; pointer-events: none;}
        
        .edit-panel { background: rgba(30,30,30,0.9); padding: 10px; border-radius: 8px; width: 100%; pointer-events: auto; text-align: center;}
        .edit-btn { padding: 12px; background: #444; color: white; border: 1px solid #777; border-radius: 5px; font-weight: bold; flex: 1;}

        #touchArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: -1; }
    </style>
</head>
<body>

    <div id="ui-container" style="display: none;">
        <div id="touchArea"></div>
        
        <div id="top-bar">
            <div id="dataPanel">
                <strong>QUOTE (dal suolo):</strong><br>
                A: <span id="hA" class="data-value">--</span>m | 
                B: <span id="hB" class="data-value">--</span>m<br>
                Distanza: <span id="distAB" class="data-value">--</span>m
            </div>

            <div id="antennaPanel">
                <strong>Configura Antenna</strong>
                <select id="antType">
                    <option value="dipole" selected>Dipolo (1/2 Œª)</option>
                    <option value="endfed">End Fed</option>
                    <option value="longwire">Long Wire</option>
                    <option value="none">Solo Filo</option>
                </select>
                <div id="setDipole" class="ant-settings">
                    Banda: <select id="dipoleBand">
                        <option value="80">80m (~40m)</option>
                        <option value="40" selected>40m (~20m)</option>
                        <option value="20">20m (~10m)</option>
                        <option value="10">10m (~5m)</option>
                    </select>
                </div>
                <div id="warning">‚ö†Ô∏è Spazio insufficiente!</div>
            </div>
        </div>

        <div class="bottom-controls">
            <div id="panel-setup-ground" class="edit-panel" style="display: none;">
                <div style="margin-bottom: 8px;">CALIBRAZIONE SUOLO</div>
                <div style="display: flex; gap: 5px;">
                    <button class="edit-btn" id="btnSetByHeight">Usa Altezza (1.5m)</button>
                    <button class="edit-btn" id="btnSetByTouch">3 Tocchi (Precisione)</button>
                </div>
            </div>

            <div id="panel-edit-point" class="edit-panel" style="display: none;">
                <div style="font-size: 12px; margin-bottom: 5px; color: #ffdd59;">TRASCINA per correggere o usa i tasti:</div>
                <div style="display: flex; gap: 5px;">
                    <button class="edit-btn" id="btnPFar">Lontano ‚ÜóÔ∏è</button>
                    <button class="edit-btn" id="btnPNear">Vicino ‚ÜôÔ∏è</button>
                </div>
            </div>

            <div id="instruction">Inizializzazione...</div>

            <div class="btn-row">
                <button id="btnGround" class="main-btn">1. SUOLO</button>
                <button id="btnA" class="main-btn">2. PUNTO A</button>
                <button id="btnB" class="main-btn">3. PUNTO B</button>
            </div>
            <div class="btn-row">
                <button id="btnReset" class="main-btn" style="background: #555;">üîÑ RESET</button>
                <button id="btnPhoto" class="main-btn" style="background: #eee; color: #000;">üì∏ FOTO</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let container, camera, scene, renderer, reticle;
        let hitTestSource = null, hitTestSourceRequested = false;
        let point1, point2, groundGrid, lineAB;
        let antennaMeshes = [], textSprites = [];
        let groundLevel = 0, isGroundSet = false;
        let currentAction = 'NONE';
        let shot1Pos = new THREE.Vector3(), shot1Dir = new THREE.Vector3(), isShot1Done = false;
        let lastTouchX = 0, lastTouchY = 0, isDragging = false;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);

            const light = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test', 'dom-overlay'],
                domOverlay: { root: document.getElementById('ui-container') }
            }));

            // Elementi grafici
            groundGrid = new THREE.GridHelper(20, 40, 0x2ed573, 0x222222);
            groundGrid.visible = false;
            scene.add(groundGrid);

            const pointGeo = new THREE.SphereGeometry(0.06, 32, 32);
            point1 = new THREE.Mesh(pointGeo, new THREE.MeshPhongMaterial({ color: 0xff4757 }));
            point2 = new THREE.Mesh(pointGeo, new THREE.MeshPhongMaterial({ color: 0x1e90ff }));
            point1.visible = point2.visible = false;
            scene.add(point1, point2);

            lineAB = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xffdd59 }));
            scene.add(lineAB);

            // Mirino migliorato
            const reticleGeo = new THREE.RingGeometry(0.03, 0.04, 32).rotateX(-Math.PI / 2);
            reticle = new THREE.Mesh(reticleGeo, new THREE.MeshBasicMaterial());
            reticle.visible = false;
            scene.add(reticle);

            // Event Listeners UI
            document.getElementById('btnGround').onclick = () => setAction('MENU_GROUND');
            document.getElementById('btnSetByHeight').onclick = () => {
                groundLevel = camera.position.y - 1.5;
                confirmGround();
            };
            document.getElementById('btnSetByTouch').onclick = () => setAction('PLACE_GROUND');
            document.getElementById('btnA').onclick = () => { isShot1Done = false; setAction('TRI_A'); };
            document.getElementById('btnB').onclick = () => { isShot1Done = false; setAction('TRI_B'); };
            document.getElementById('btnReset').onclick = () => location.reload();
            
            // Logica Dragging per correzione fine
            const touchArea = document.getElementById('touchArea');
            touchArea.ontouchstart = (e) => {
                if (currentAction.includes('EDIT')) {
                    isDragging = true;
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
            };
            touchArea.ontouchmove = (e) => {
                if (!isDragging) return;
                let pt = currentAction === 'EDIT_A' ? point1 : point2;
                let dx = (e.touches[0].clientX - lastTouchX) * 0.001 * camera.position.distanceTo(pt.position);
                let dy = (e.touches[0].clientY - lastTouchY) * 0.001 * camera.position.distanceTo(pt.position);
                
                const right = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
                const up = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);
                pt.position.addScaledVector(right, dx);
                pt.position.addScaledVector(up, -dy);
                
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                updateCalculations();
            };
            touchArea.ontouchend = () => isDragging = false;

            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ui-container').style.display = 'flex';
                setAction('MENU_GROUND');
            });
        }

        function setAction(action) {
            currentAction = action;
            document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('panel-setup-ground').style.display = action === 'MENU_GROUND' ? 'block' : 'none';
            document.getElementById('panel-edit-point').style.display = action.includes('EDIT') ? 'block' : 'none';
            
            let inst = document.getElementById('instruction');
            switch(action) {
                case 'MENU_GROUND': inst.innerText = "Configura il livello del terreno"; break;
                case 'PLACE_GROUND': inst.innerText = "Mira il suolo e tocca per calibrare"; break;
                case 'TRI_A': inst.innerText = "PUNTO A: Mira il ramo e tocca"; break;
                case 'TRI_B': inst.innerText = "PUNTO B: Mira il ramo e tocca"; break;
                case 'EDIT_A': case 'EDIT_B': inst.innerText = "Trascina il punto per correggere la mira"; break;
                default: inst.innerText = "Pronto per le misure";
            }
        }

        function confirmGround() {
            groundGrid.position.y = groundLevel;
            groundGrid.visible = isGroundSet = true;
            setAction('NONE');
        }

        // --- CORE ALGORITHM: Triangolazione Linee Sghembe ---
        function calculateTriangulation(p1, d1, p2, d2) {
            const cross = new THREE.Vector3().crossVectors(d1, d2);
            const denom = cross.lengthSq();
            if (denom < 0.0001) return p1.clone().add(d1.clone().multiplyScalar(5));

            const detL = new THREE.Vector3().subVectors(p2, p1);
            const s = new THREE.Vector3().crossVectors(detL, d2).dot(cross) / denom;
            const t = new THREE.Vector3().crossVectors(detL, d1).dot(cross) / denom;

            const pA = p1.clone().add(d1.clone().multiplyScalar(s));
            const pB = p2.clone().add(d2.clone().multiplyScalar(t));
            return new THREE.Vector3().addVectors(pA, pB).multiplyScalar(0.5);
        }

        function updateCalculations() {
            if (!point1.visible || !point2.visible) return;
            const dist = point1.position.distanceTo(point2.position);
            document.getElementById('distAB').innerText = dist.toFixed(2);
            document.getElementById('hA').innerText = (point1.position.y - groundLevel).toFixed(1);
            document.getElementById('hB').innerText = (point2.position.y - groundLevel).toFixed(1);
            
            lineAB.geometry.setFromPoints([point1.position, point2.position]);
            document.getElementById('antennaPanel').style.display = 'block';
            drawAntenna();
        }

        function drawAntenna() {
            antennaMeshes.forEach(m => scene.remove(m));
            antennaMeshes = [];
            // Qui andrebbe la logica di disegno dei fili (cilindri) come nel tuo codice
            // Per brevit√† simuliamo l'ingombro
            const dist = point1.position.distanceTo(point2.position);
            const required = parseFloat(document.getElementById('dipoleBand').value) / 2;
            document.getElementById('warning').style.display = required > dist ? 'block' : 'none';
        }

        renderer.xr.getController(0).addEventListener('select', () => {
            if (currentAction === 'PLACE_GROUND' && reticle.visible) {
                groundLevel = reticle.position.y;
                confirmGround();
            } else if (currentAction === 'TRI_A' || currentAction === 'TRI_B') {
                const camPos = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
                const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                
                if (!isShot1Done) {
                    shot1Pos.copy(camPos); shot1Dir.copy(camDir);
                    isShot1Done = true;
                    document.getElementById('instruction').innerText = "Spostati di lato e scatta di nuovo";
                } else {
                    const result = calculateTriangulation(shot1Pos, shot1Dir, camPos, camDir);
                    if (currentAction === 'TRI_A') {
                        point1.position.copy(result); point1.visible = true; setAction('EDIT_A');
                    } else {
                        point2.position.copy(result); point2.visible = true; setAction('EDIT_B');
                    }
                    updateCalculations();
                }
            }
        });

        function animate() {
            renderer.setAnimationLoop((timestamp, frame) => {
                if (frame) {
                    const session = renderer.xr.getSession();
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    
                    if (!hitTestSourceRequested) {
                        session.requestReferenceSpace('viewer').then(space => {
                            session.requestHitTestSource({ space }).then(source => hitTestSource = source);
                        });
                        hitTestSourceRequested = true;
                    }

                    if (currentAction === 'PLACE_GROUND' && hitTestSource) {
                        const hitResults = frame.getHitTestResults(hitTestSource);
                        if (hitResults.length) {
                            const pose = hitResults[0].getPose(referenceSpace);
                            reticle.visible = true;
                            reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                        }
                    } else if (currentAction.includes('TRI')) {
                        // Mirino fisso al centro per puntamento alberi
                        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        reticle.position.copy(camera.position).add(dir.multiplyScalar(2));
                        reticle.quaternion.copy(camera.quaternion);
                        reticle.visible = true;
                    } else {
                        reticle.visible = false;
                    }
                    
                    // Scaling icone per visibilit√† costante
                    [point1, point2].forEach(p => {
                        if(p.visible) {
                            const d = camera.position.distanceTo(p.position);
                            p.scale.setScalar(d * 0.1);
                        }
                    });
                }
                renderer.render(scene, camera);
            });
        }
    </script>
</body>
</html>
