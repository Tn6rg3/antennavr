<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Ham Radio Planner Pro - Fix</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; color: white; touch-action: none; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; z-index: 100; pointer-events: none; padding: 10px; box-sizing: border-box; }
        #top-bar { display: flex; justify-content: space-between; width: 100%; pointer-events: auto; }
        #dataPanel { background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; font-size: 13px; border-left: 4px solid #ffdd59; min-width: 120px; }
        .data-value { font-weight: bold; color: #ffdd59; font-size: 15px; }
        
        #settingsPanel { background: rgba(20,20,20,0.9); padding: 10px; border-radius: 8px; pointer-events: auto; font-size: 12px; }
        input[type="number"] { width: 50px; background: #333; color: white; border: 1px solid #555; padding: 3px; border-radius: 4px; }

        .bottom-controls { display: flex; flex-direction: column; gap: 8px; width: 100%; align-items: center; }
        #instruction { background: #ffdd59; color: black; padding: 8px; border-radius: 5px; font-weight: bold; width: 100%; text-align: center; font-size: 13px; }
        .btn-row { display: flex; gap: 5px; width: 100%; pointer-events: auto; }
        .main-btn { flex: 1; padding: 12px 5px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; color: white; opacity: 0.8; }
        .main-btn.active { opacity: 1; outline: 2px solid white; transform: scale(1.02); }
        #btnGround { background: #2ed573; color: black; }
        #btnA { background: #ff4757; }
        #btnB { background: #1e90ff; }
        
        .edit-panel { background: rgba(40,40,40,0.9); padding: 10px; border-radius: 8px; width: 100%; pointer-events: auto; display: none; text-align: center; }
        #touchArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: -1; }
    </style>
</head>
<body>

    <div id="ui-container" style="display: none;">
        <div id="touchArea"></div>

        <div id="top-bar">
            <div id="dataPanel">
                A: <span id="hA" class="data-value">--</span>m | B: <span id="hB" class="data-value">--</span>m<br>
                Dist: <span id="distAB" class="data-value">--</span>m
            </div>
            <div id="settingsPanel">
                H Cell: <input type="number" id="inpHCell" value="1.50" step="0.05">m<br>
                Grid: <input type="number" id="inpGrid" value="3.0" step="0.5">m
            </div>
        </div>

        <div class="bottom-controls">
            <div id="ground-opts" class="edit-panel">
                <button class="main-btn" id="btnHManual" style="background:#444">Applica H Manuale</button>
                <button class="main-btn" id="btn3Tocchi" style="background:#444">Inizia 3 Tocchi</button>
            </div>

            <div id="instruction">Inizializzazione AR...</div>
            
            <div class="btn-row">
                <button id="btnGround" class="main-btn active">1. SUOLO</button>
                <button id="btnA" class="main-btn">2. PUNTO A</button>
                <button id="btnB" class="main-btn">3. PUNTO B</button>
            </div>
            <div class="btn-row">
                <button id="btnReset" class="main-btn" style="background:#555">RESET</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let scene, camera, renderer, reticle, groundGrid;
        let hitTestSource = null, hitTestSourceRequested = false;
        let point1, point2;
        let groundLevel = 0, isGroundSet = false;
        let currentAction = 'MENU_GROUND';
        
        // Triangolazione
        let shot1Pos = new THREE.Vector3(), shot1Dir = new THREE.Vector3(), isShot1Done = false;
        let groundPoints = []; 
        let tempMarkers = [];

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test', 'dom-overlay'],
                domOverlay: { root: document.getElementById('ui-container') }
            }));

            // Grafica
            groundGrid = new THREE.GridHelper(3, 10, 0x2ed573, 0x444444);
            groundGrid.visible = false;
            scene.add(groundGrid);

            const pGeo = new THREE.SphereGeometry(0.05);
            point1 = new THREE.Mesh(pGeo, new THREE.MeshBasicMaterial({color: 0xff4757}));
            point2 = new THREE.Mesh(pGeo, new THREE.MeshBasicMaterial({color: 0x1e90ff}));
            point1.visible = point2.visible = false;
            scene.add(point1, point2);

            reticle = new THREE.Mesh(new THREE.RingGeometry(0.03, 0.04, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial());
            reticle.visible = false;
            scene.add(reticle);

            // UI Events
            document.getElementById('btnGround').onclick = () => { setAction('MENU_GROUND'); document.getElementById('ground-opts').style.display='flex'; };
            document.getElementById('btnA').onclick = () => { isShot1Done = false; setAction('TRI_A'); };
            document.getElementById('btnB').onclick = () => { isShot1Done = false; setAction('TRI_B'); };
            document.getElementById('btnReset').onclick = () => location.reload();

            document.getElementById('btnHManual').onclick = () => {
                const h = parseFloat(document.getElementById('inpHCell').value);
                groundLevel = camera.position.y - h;
                applyGround();
            };

            document.getElementById('btn3Tocchi').onclick = () => {
                groundPoints = [];
                setAction('PLACE_GROUND_3');
            };

            renderer.xr.addEventListener('sessionstart', () => {
                document.getElementById('ui-container').style.display = 'flex';
                document.getElementById('ground-opts').style.display = 'flex';
            });

            renderer.setAnimationLoop(render);
        }

        function setAction(action) {
            currentAction = action;
            isShot1Done = false; // Reset ogni volta che cambiamo azione
            document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));
            if(action === 'MENU_GROUND' || action === 'PLACE_GROUND_3') document.getElementById('btnGround').classList.add('active');
            if(action === 'TRI_A') document.getElementById('btnA').classList.add('active');
            if(action === 'TRI_B') document.getElementById('btnB').classList.add('active');

            let inst = document.getElementById('instruction');
            if(action === 'TRI_A') inst.innerText = "ALBERO A: Mira e fai il 1° tocco";
            else if(action === 'TRI_B') inst.innerText = "ALBERO B: Mira e fai il 1° tocco";
            else if(action === 'PLACE_GROUND_3') inst.innerText = `Tocca il suolo (${3 - groundPoints.length} rimasti)`;
            else inst.innerText = "Pronto";
        }

        function applyGround() {
            const size = parseFloat(document.getElementById('inpGrid').value) || 3;
            scene.remove(groundGrid);
            groundGrid = new THREE.GridHelper(size, 10, 0x2ed573, 0x444444);
            groundGrid.position.y = groundLevel;
            groundGrid.visible = true;
            scene.add(groundGrid);
            isGroundSet = true;
            document.getElementById('ground-opts').style.display='none';
            setAction('NONE');
        }

        // Triangolazione migliorata
        function calculateTri(p1, d1, p2, d2) {
            const cross = new THREE.Vector3().crossVectors(d1, d2);
            const denom = cross.lengthSq();
            const detL = new THREE.Vector3().subVectors(p2, p1);
            const s = new THREE.Vector3().crossVectors(detL, d2).dot(cross) / denom;
            const t = new THREE.Vector3().crossVectors(detL, d1).dot(cross) / denom;
            const pA = p1.clone().add(d1.clone().multiplyScalar(s));
            const pB = p2.clone().add(d2.clone().multiplyScalar(t));
            return new THREE.Vector3().addVectors(pA, pB).multiplyScalar(0.5);
        }

        renderer.xr.getController(0).addEventListener('select', () => {
            if (currentAction === 'PLACE_GROUND_3' && reticle.visible) {
                groundPoints.push(reticle.position.y);
                let m = new THREE.Mesh(new THREE.SphereGeometry(0.02), new THREE.MeshBasicMaterial({color: 0xffff00}));
                m.position.copy(reticle.position); scene.add(m); tempMarkers.push(m);
                
                if (groundPoints.length >= 3) {
                    groundLevel = groundPoints.reduce((a,b)=>a+b, 0) / 3;
                    tempMarkers.forEach(obj => scene.remove(obj));
                    applyGround();
                } else {
                    setAction('PLACE_GROUND_3');
                }
            } 
            else if (currentAction === 'TRI_A' || currentAction === 'TRI_B') {
                const cPos = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
                const cDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);

                if (!isShot1Done) {
                    shot1Pos.copy(cPos); shot1Dir.copy(cDir);
                    isShot1Done = true;
                    document.getElementById('instruction').innerText = "Spostati di lato e mira di nuovo (2° tocco)";
                } else {
                    const res = calculateTri(shot1Pos, shot1Dir, cPos, cDir);
                    if (currentAction === 'TRI_A') { point1.position.copy(res); point1.visible = true; }
                    else { point2.position.copy(res); point2.visible = true; }
                    
                    isShot1Done = false; // Reset per sicurezza
                    updateUI();
                    setAction('NONE');
                }
            }
        });

        function updateUI() {
            if(point1.visible) document.getElementById('hA').innerText = (point1.position.y - groundLevel).toFixed(1);
            if(point2.visible) document.getElementById('hB').innerText = (point2.position.y - groundLevel).toFixed(1);
            if(point1.visible && point2.visible) {
                document.getElementById('distAB').innerText = point1.position.distanceTo(point2.position).toFixed(2);
            }
        }

        function render(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                const refSpace = renderer.xr.getReferenceSpace();
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(space => {
                        session.requestHitTestSource({ space }).then(src => hitTestSource = src);
                    });
                    hitTestSourceRequested = true;
                }

                if (currentAction === 'PLACE_GROUND_3' && hitTestSource) {
                    const hits = frame.getHitTestResults(hitTestSource);
                    if (hits.length) {
                        const pose = hits[0].getPose(refSpace);
                        reticle.visible = true;
                        reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                    }
                } else if (currentAction.includes('TRI')) {
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                    reticle.position.copy(camera.position).add(dir.multiplyScalar(2));
                    reticle.quaternion.copy(camera.quaternion);
                    reticle.visible = true;
                } else {
                    reticle.visible = false;
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
